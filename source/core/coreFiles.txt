#ifndef VEHICLEMANAGER_H
#define VEHICLEMANAGER_H

#include "../../include/sdm_types.hpp"
#include "../../source/core/DatabaseManager.h"
#include "../../source/core/CacheManager.h"
#include "../../source/core/IndexManager.h"
#include "../../source/data_structures/MinHeap.h"
#include <vector>
#include <string>
#include <set>

class VehicleManager
{
private:
    DatabaseManager &db_;
    CacheManager &cache_;
    IndexManager &index_;
    set<string> processed_alerts_;
    // Maintenance alert priority queue
    MaintenanceAlertQueue alert_queue_;

    // Alert priority calculation
    uint32_t calculate_alert_priority(const VehicleInfo &vehicle,
                                      const MaintenanceRecord &last_service,
                                      MaintenanceType type)
    {
        uint64_t current_time = get_current_timestamp();

        // Days since last service
        uint64_t days_overdue = 0;
        if (last_service.next_service_date > 0 && current_time > last_service.next_service_date)
        {
            days_overdue = (current_time - last_service.next_service_date) / (86400 * 1000000000ULL);
        }

        // Severity based on type
        uint8_t severity = 2; // Medium
        switch (type)
        {
        case MaintenanceType::BRAKE_SERVICE:
        case MaintenanceType::ENGINE_CHECK:
            severity = 4; // Critical
            break;
        case MaintenanceType::OIL_CHANGE:
        case MaintenanceType::TRANSMISSION:
            severity = 3; // High
            break;
        default:
            severity = 2; // Medium
            break;
        }

        // Lower priority number = more urgent
        uint32_t priority = 1000;
        priority -= (days_overdue * 20);
        priority -= (severity * 50);

        // Odometer check
        if (vehicle.current_odometer > last_service.next_service_odometer)
        {
            double km_overdue = vehicle.current_odometer - last_service.next_service_odometer;
            priority -= (km_overdue / 100);
        }

        return (priority > 0) ? priority : 1;
    }
    void clear_maintenance_alerts_for_vehicle_and_type(uint64_t vehicle_id, MaintenanceType type)
    {
        std::string alert_key = std::to_string(vehicle_id) + "_" +
                                std::to_string(static_cast<int>(type));
        processed_alerts_.erase(alert_key);

        // Rebuild alert queue without this type
        auto all_alerts = alert_queue_.get_top_k(1000);

        while (!alert_queue_.empty())
        {
            alert_queue_.extract_min();
        }

        std::string type_string = get_maintenance_type_string(type);
        for (const auto &alert : all_alerts)
        {
            if (!(alert.vehicle_id == vehicle_id &&
                  std::string(alert.description).find(type_string) != std::string::npos))
            {
                alert_queue_.insert(alert);
            }
        }
    }

public:
    void check_maintenance_alerts(const VehicleInfo &vehicle)
    {
        auto maintenance_history = get_vehicle_maintenance_history(vehicle.vehicle_id);

        if (maintenance_history.empty())
        {
            std::string alert_key = std::to_string(vehicle.vehicle_id) + "_initial";

            if (processed_alerts_.find(alert_key) == processed_alerts_.end())
            {
                MaintenanceAlert alert(
                    vehicle.vehicle_id,
                    generate_alert_id(),
                    500,
                    get_current_timestamp(),
                    "Initial maintenance check required",
                    2);
                alert_queue_.insert(alert);
                processed_alerts_.insert(alert_key);
            }
            return;
        }

        MaintenanceType types[] = {
            MaintenanceType::OIL_CHANGE,
            MaintenanceType::BRAKE_SERVICE,
            MaintenanceType::TIRE_ROTATION,
            MaintenanceType::ENGINE_CHECK};

        for (auto type : types)
        {
            MaintenanceRecord *last_service = nullptr;
            for (auto &record : maintenance_history)
            {
                if (record.type == type)
                {
                    if (!last_service || record.service_date > last_service->service_date)
                    {
                        last_service = &record;
                    }
                }
            }

            if (last_service && last_service->next_service_date > 0)
            {
                uint64_t current_time = get_current_timestamp();

                if (current_time >= last_service->next_service_date ||
                    vehicle.current_odometer >= last_service->next_service_odometer)
                {
                    std::string alert_key = std::to_string(vehicle.vehicle_id) + "_" +
                                            std::to_string(static_cast<int>(type));

                    if (processed_alerts_.find(alert_key) == processed_alerts_.end())
                    {
                        uint32_t priority = calculate_alert_priority(vehicle, *last_service, type);
                        std::string desc = get_maintenance_type_string(type) + " is due";

                        MaintenanceAlert alert(
                            vehicle.vehicle_id,
                            generate_alert_id(),
                            priority,
                            last_service->next_service_date,
                            desc,
                            get_maintenance_severity(type));

                        alert_queue_.insert(alert);
                        processed_alerts_.insert(alert_key);
                    }
                }
            }
        }
    }

    VehicleManager(DatabaseManager &db, CacheManager &cache, IndexManager &index)
        : db_(db), cache_(cache), index_(index) {}

    // ========================================================================
    // VEHICLE OPERATIONS
    // ========================================================================

    uint64_t add_vehicle(const std::string &license_plate,
                         const std::string &make,
                         const std::string &model,
                         uint32_t year,
                         VehicleType type,
                         uint64_t owner_driver_id,
                         const std::string &vin = "")
    {
        // Check if license plate already exists
        uint64_t existing_id;
        if (index_.search_by_plate(license_plate, existing_id))
        {
            return 0; // Already exists
        }

        // Generate vehicle ID
        uint64_t vehicle_id = generate_vehicle_id();

        // Create vehicle
        VehicleInfo vehicle;
        vehicle.vehicle_id = vehicle_id;
        vehicle.owner_driver_id = owner_driver_id;
        strncpy(vehicle.license_plate, license_plate.c_str(), sizeof(vehicle.license_plate) - 1);
        strncpy(vehicle.make, make.c_str(), sizeof(vehicle.make) - 1);
        strncpy(vehicle.model, model.c_str(), sizeof(vehicle.model) - 1);
        vehicle.year = year;
        vehicle.type = type;
        strncpy(vehicle.vin, vin.c_str(), sizeof(vehicle.vin) - 1);
        vehicle.is_active = 1;
        vehicle.created_time = get_current_timestamp();

        // Save to database
        if (!db_.create_vehicle(vehicle))
        {
            return 0;
        }

        // Add to index
        index_.insert_vehicle_plate(license_plate, vehicle_id);
        index_.insert_primary(2, vehicle_id, vehicle.created_time, 0); // entity_type=2

        // Cache it
        cache_.put_vehicle(vehicle_id, vehicle);

        return vehicle_id;
    }

    bool update_vehicle(const VehicleInfo &vehicle)
    {
        if (!db_.update_vehicle(vehicle))
        {
            return false;
        }

        cache_.put_vehicle(vehicle.vehicle_id, vehicle, true);
        return true;
    }

    bool delete_vehicle(uint64_t vehicle_id)
    {
        if (!db_.delete_vehicle(vehicle_id))
        {
            return false;
        }

        cache_.invalidate_vehicle(vehicle_id);
        return true;
    }

    bool get_vehicle(uint64_t vehicle_id, VehicleInfo &vehicle)
    {
        // Try cache
        if (cache_.get_vehicle(vehicle_id, vehicle))
        {
            return true;
        }

        // Fetch from database
        if (db_.read_vehicle(vehicle_id, vehicle))
        {
            cache_.put_vehicle(vehicle_id, vehicle);
            return true;
        }

        return false;
    }

    bool get_vehicle_by_plate(const std::string &license_plate, VehicleInfo &vehicle)
    {
        // Search index
        uint64_t vehicle_id;
        if (!index_.search_by_plate(license_plate, vehicle_id))
        {
            return false;
        }

        return get_vehicle(vehicle_id, vehicle);
    }

    std::vector<VehicleInfo> get_driver_vehicles(uint64_t driver_id)
    {
        return db_.get_vehicles_by_owner(driver_id);
    }

    // ========================================================================
    // ODOMETER UPDATES
    // ========================================================================

    bool update_odometer(uint64_t vehicle_id, double new_reading)
    {
        VehicleInfo vehicle;
        if (!get_vehicle(vehicle_id, vehicle))
        {
            return false;
        }

        if (new_reading < vehicle.current_odometer)
        {
            return false; // Invalid reading
        }

        vehicle.current_odometer = new_reading;

        // Check if maintenance is due
        check_maintenance_due(vehicle);

        return update_vehicle(vehicle);
    }
    void refresh_all_alerts()
    {
        processed_alerts_.clear();

        while (!alert_queue_.empty())
        {
            alert_queue_.extract_min();
        }
    }
    uint64_t add_maintenance_record(uint64_t vehicle_id,
                                    uint64_t driver_id,
                                    MaintenanceType type,
                                    double odometer_reading,
                                    const std::string &service_center,
                                    const std::string &description,
                                    double total_cost)
    {
        uint64_t maintenance_id = generate_maintenance_id();

        MaintenanceRecord record;
        record.maintenance_id = maintenance_id;
        record.vehicle_id = vehicle_id;
        record.driver_id = driver_id;
        record.type = type;
        record.service_date = get_current_timestamp();
        record.odometer_reading = odometer_reading;
        strncpy(record.service_center, service_center.c_str(), sizeof(record.service_center) - 1);
        strncpy(record.description, description.c_str(), sizeof(record.description) - 1);
        record.total_cost = total_cost;

        calculate_next_service(record);

        if (!db_.create_maintenance(record))
        {
            return 0;
        }

        VehicleInfo vehicle;
        if (get_vehicle(vehicle_id, vehicle))
        {
            vehicle.last_maintenance_date = record.service_date;
            vehicle.last_service_odometer = odometer_reading;
            vehicle.next_maintenance_due = record.next_service_date;
            update_vehicle(vehicle);
        }

        // CLEAR OLD ALERTS
        clear_maintenance_alerts_for_vehicle_and_type(vehicle_id, type);

        std::cout << "\n✓ Maintenance record added and alerts updated" << std::endl;

        return maintenance_id;
    }
    std::vector<MaintenanceRecord> get_vehicle_maintenance_history(uint64_t vehicle_id)
    {
        return db_.get_maintenance_by_vehicle(vehicle_id);
    }

    // ========================================================================
    // MAINTENANCE ALERTS
    // ========================================================================

    void refresh_maintenance_alerts()
    {
        alert_queue_.clear();

        // Get all vehicles
        auto all_drivers = db_.get_all_drivers();
        for (const auto &driver : all_drivers)
        {
            auto vehicles = get_driver_vehicles(driver.driver_id);

            for (const auto &vehicle : vehicles)
            {
                check_maintenance_alerts(vehicle);
            }
        }
    }

    std::vector<MaintenanceAlert> get_top_alerts(int count = 10)
    {
        return alert_queue_.get_top_k(count);
    }

    MaintenanceAlert get_next_alert()
    {
        if (alert_queue_.empty())
        {
            throw std::runtime_error("No maintenance alerts");
        }
        return alert_queue_.peek();
    }

    void acknowledge_alert(uint64_t alert_id)
    {
        // Would remove from queue by ID
        // Simplified: just extract if it's at top
        if (!alert_queue_.empty())
        {
            auto top = alert_queue_.peek();
            if (top.alert_id == alert_id)
            {
                alert_queue_.extract_min();
            }
        }
    }

    // ========================================================================
    // HELPER FUNCTIONS
    // ========================================================================

private:
    uint64_t generate_vehicle_id()
    {
        static uint64_t counter = 1;
        return counter++;
    }

    uint64_t generate_maintenance_id()
    {
        static uint64_t counter = 1;
        return counter++;
    }

    uint64_t generate_alert_id()
    {
        static uint64_t counter = 1;
        return counter++;
    }

    uint64_t get_current_timestamp()
    {
        return std::chrono::system_clock::now().time_since_epoch().count();
    }

    void calculate_next_service(MaintenanceRecord &record)
    {
        uint64_t current_time = get_current_timestamp();
        const uint64_t NANOSECONDS_PER_DAY = 86400ULL * 1000000000ULL;

        switch (record.type)
        {
        case MaintenanceType::OIL_CHANGE:
            record.next_service_date = current_time + (90 * NANOSECONDS_PER_DAY); // 3 months
            record.next_service_odometer = record.odometer_reading + 5000;        // 5000 km
            break;
        case MaintenanceType::TIRE_ROTATION:
            record.next_service_date = current_time + (180 * NANOSECONDS_PER_DAY); // 6 months
            record.next_service_odometer = record.odometer_reading + 10000;
            break;
        case MaintenanceType::BRAKE_SERVICE:
            record.next_service_date = current_time + (365 * NANOSECONDS_PER_DAY); // 1 year
            record.next_service_odometer = record.odometer_reading + 20000;
            break;
        case MaintenanceType::ENGINE_CHECK:
            record.next_service_date = current_time + (365 * NANOSECONDS_PER_DAY); // 1 year
            record.next_service_odometer = record.odometer_reading + 15000;
            break;
        default:
            record.next_service_date = current_time + (180 * NANOSECONDS_PER_DAY);
            record.next_service_odometer = record.odometer_reading + 10000;
            break;
        }
    }
    void check_maintenance_due(const VehicleInfo &vehicle)
    {
        // Check if any maintenance is overdue and create alerts
        check_maintenance_alerts(vehicle);
    }

    std::string get_maintenance_type_string(MaintenanceType type)
    {
        switch (type)
        {
        case MaintenanceType::OIL_CHANGE:
            return "Oil Change";
        case MaintenanceType::TIRE_ROTATION:
            return "Tire Rotation";
        case MaintenanceType::BRAKE_SERVICE:
            return "Brake Service";
        case MaintenanceType::ENGINE_CHECK:
            return "Engine Check";
        case MaintenanceType::TRANSMISSION:
            return "Transmission Service";
        default:
            return "General Service";
        }
    }

    uint8_t get_maintenance_severity(MaintenanceType type)
    {
        switch (type)
        {
        case MaintenanceType::BRAKE_SERVICE:
        case MaintenanceType::ENGINE_CHECK:
            return 4; // Critical
        case MaintenanceType::OIL_CHANGE:
        case MaintenanceType::TRANSMISSION:
            return 3; // High
        default:
            return 2; // Medium
        }
    }
};
#endif // VEHICLEMANAGER_H
// File Location: source/modules/TripManager.h
// Smart Drive Manager - Trip Management & GPS Logging

#ifndef TRIPMANAGER_H
#define TRIPMANAGER_H

#include "../../include/sdm_types.hpp"
#include "../../source/core/DatabaseManager.h"
#include "../../source/core/CacheManager.h"
#include "../../source/core/IndexManager.h"
#include "../../source/data_structures/CircularQueue.h"
#include "../../source/data_structures/DoublyLinkedList.h"
#include <vector>
#include <cmath>
#include <algorithm>

class TripManager
{
private:
    DatabaseManager &db_;
    CacheManager &cache_;
    IndexManager &index_;
    // GPS data buffer
    CircularQueue<GPSWaypoint> gps_buffer_;

    // Active trips
    struct ActiveTrip
    {
        uint64_t trip_id;
        TripRecord record;
        std::vector<GPSWaypoint> waypoints;
        uint64_t start_time;
        bool vision_active;
    };

    std::vector<ActiveTrip> active_trips_;

    // Constants
    static constexpr double EARTH_RADIUS_KM = 6371.0;
    static constexpr double HARSH_BRAKING_THRESHOLD = -3.0;     // m/s²
    static constexpr double RAPID_ACCELERATION_THRESHOLD = 3.0; // m/s²
    static constexpr double SPEEDING_THRESHOLD = 120.0;         // km/h
    void update_driver_safety_score(uint64_t driver_id, int delta)
    {
        DriverProfile driver;
        if (db_.read_driver(driver_id, driver))
        {
            int new_score = (int)driver.safety_score + delta;

            if (new_score < 0)
                new_score = 0;
            if (new_score > 1000)
                new_score = 1000;

            driver.safety_score = (uint32_t)new_score;

            db_.update_driver(driver);
            cache_.invalidate_driver(driver_id);
        }
    }

public:
    TripManager(DatabaseManager &db, CacheManager &cache, IndexManager &index,
                size_t gps_buffer_size = 50000)
        : db_(db), cache_(cache), index_(index),
          gps_buffer_(gps_buffer_size) {}

    // ========================================================================
    // TRIP LIFECYCLE
    // ========================================================================

    uint64_t start_trip(uint64_t driver_id, uint64_t vehicle_id,
                        double start_lat, double start_lon,
                        const std::string &start_address = "")
    {
        // Generate trip ID
        uint64_t trip_id = generate_trip_id();

        // Create trip record
        TripRecord trip;
        trip.trip_id = trip_id;
        trip.driver_id = driver_id;
        trip.vehicle_id = vehicle_id;
        trip.start_time = get_current_timestamp();
        trip.start_latitude = start_lat;
        trip.start_longitude = start_lon;
        strncpy(trip.start_address, start_address.c_str(), sizeof(trip.start_address) - 1);

        // Save to database
        if (!db_.create_trip(trip))
        {
            return 0; // Failed
        }

        // Add to index
        index_.insert_primary(3, trip_id, trip.start_time, 0); // entity_type=3 for Trip

        // Create active trip
        ActiveTrip active;
        active.trip_id = trip_id;
        active.record = trip;
        active.start_time = trip.start_time;
        active.vision_active = false;
        active_trips_.push_back(active);

        return trip_id;
    }

    bool log_gps_point(uint64_t trip_id, double latitude, double longitude,
                       float speed, float altitude = 0, float accuracy = 0)
    {
        // Create waypoint
        GPSWaypoint waypoint;
        waypoint.timestamp = get_current_timestamp();
        waypoint.latitude = latitude;
        waypoint.longitude = longitude;
        waypoint.speed = speed;
        waypoint.altitude = altitude;
        waypoint.accuracy = accuracy;

        // Add to buffer
        if (!gps_buffer_.try_enqueue(waypoint))
        {
            return false; // Buffer full
        }

        // Find active trip and add waypoint
        for (auto &active : active_trips_)
        {
            if (active.trip_id == trip_id)
            {
                active.waypoints.push_back(waypoint);

                // Detect driving events
                detect_driving_events(active, waypoint);

                return true;
            }
        }

        return false;
    }
    bool end_trip(uint64_t trip_id, double end_lat, double end_lon,
                  const std::string &end_address = "")
    {
        auto it = std::find_if(active_trips_.begin(), active_trips_.end(),
                               [trip_id](const ActiveTrip &t)
                               { return t.trip_id == trip_id; });

        if (it == active_trips_.end())
        {
            return false;
        }

        ActiveTrip &active = *it;

        // Stop vision processing and update safety score

        calculate_trip_metrics(active);

        active.record.end_time = get_current_timestamp();
        active.record.end_latitude = end_lat;
        active.record.end_longitude = end_lon;
        strncpy(active.record.end_address, end_address.c_str(), sizeof(active.record.end_address) - 1);
        active.record.duration = (active.record.end_time - active.record.start_time) / 1000000000;
        active.record.gps_data_count = active.waypoints.size();

        if (!db_.update_trip(active.record))
        {
            return false; // Database update failed
        }
        
        update_driver_stats(active.record);

        active_trips_.erase(it);

        return true;
    }

    void detect_driving_events(ActiveTrip &trip, const GPSWaypoint &current)
    {
        if (trip.waypoints.size() < 2)
            return;

        const GPSWaypoint &previous = trip.waypoints[trip.waypoints.size() - 2];

        double time_diff = (current.timestamp - previous.timestamp) / 1000000000.0;
        if (time_diff <= 0)
            return;

        double speed_diff = current.speed - previous.speed;
        double acceleration = (speed_diff / 3.6) / time_diff;

        if (acceleration < HARSH_BRAKING_THRESHOLD)
        {
            trip.record.harsh_braking_count++;
            update_driver_safety_score(trip.record.driver_id, -5);
        }

        if (acceleration > RAPID_ACCELERATION_THRESHOLD)
        {
            trip.record.rapid_acceleration_count++;
            update_driver_safety_score(trip.record.driver_id, -3);
        }

        if (current.speed > SPEEDING_THRESHOLD)
        {
            trip.record.speeding_count++;
            update_driver_safety_score(trip.record.driver_id, -10);
        }

        double heading_change = calculate_heading_change(previous, current);
        if (abs(heading_change) > 30 && current.speed > 20)
        {
            trip.record.sharp_turn_count++;
            update_driver_safety_score(trip.record.driver_id, -2);
        }
    }

    void calculate_trip_metrics(ActiveTrip &trip)
    {
        if (trip.waypoints.empty())
            return;

        // Calculate total distance
        double total_distance = 0;
        for (size_t i = 1; i < trip.waypoints.size(); i++)
        {
            total_distance += calculate_distance(
                trip.waypoints[i - 1].latitude, trip.waypoints[i - 1].longitude,
                trip.waypoints[i].latitude, trip.waypoints[i].longitude);
        }
        trip.record.distance = total_distance;

        // Calculate average speed
        if (trip.record.duration > 0)
        {
            trip.record.avg_speed = (total_distance / trip.record.duration) * 3600; // km/h
        }

        // Find max speed
        trip.record.max_speed = 0;
        for (const auto &waypoint : trip.waypoints)
        {
            if (waypoint.speed > trip.record.max_speed)
            {
                trip.record.max_speed = waypoint.speed;
            }
        }

        // Estimate fuel consumption (simplified formula)
        // Real implementation would use vehicle-specific parameters
        trip.record.fuel_consumed = estimate_fuel_consumption(trip.record);

        if (trip.record.fuel_consumed > 0)
        {
            trip.record.fuel_efficiency = total_distance / trip.record.fuel_consumed;
        }
    }

    // ========================================================================
    // TRIP QUERIES
    // ========================================================================

    std::vector<TripRecord> get_driver_trips(uint64_t driver_id, int limit = 100)
    {
        // Check cache first
        std::vector<uint64_t> cached_trip_ids;
        std::string cache_key = "driver_trips_" + std::to_string(driver_id);

        if (cache_.get_query_result(cache_key, cached_trip_ids))
        {
            std::vector<TripRecord> trips;
            for (uint64_t trip_id : cached_trip_ids)
            {
                TripRecord trip;
                if (db_.read_trip(trip_id, trip))
                {
                    trips.push_back(trip);
                }
                if (trips.size() >= limit)
                    break;
            }
            return trips;
        }

        // Fetch from database
        auto trips = db_.get_trips_by_driver(driver_id, limit);

        // Cache trip IDs
        cached_trip_ids.clear();
        for (const auto &trip : trips)
        {
            cached_trip_ids.push_back(trip.trip_id);
        }
        cache_.put_query_result(cache_key, cached_trip_ids);

        return trips;
    }

    std::vector<TripRecord> get_trips_by_date_range(uint64_t driver_id,
                                                    uint64_t start_time,
                                                    uint64_t end_time)
    {
        std::vector<TripRecord> trips;

        // Use index for range query
        auto offsets = index_.range_query_primary(3, driver_id, start_time, end_time);

        for (uint64_t offset : offsets)
        {
            TripRecord trip;
            // In production, would read from offset directly
            // For now, linear search in database
            auto all_trips = db_.get_trips_by_driver(driver_id, 10000);
            for (const auto &t : all_trips)
            {
                if (t.start_time >= start_time && t.start_time <= end_time)
                {
                    trips.push_back(t);
                }
            }
        }

        return trips;
    }

    bool get_trip_details(uint64_t trip_id, TripRecord &trip)
    {
        // Try cache first
        if (cache_.get_trip(trip_id, trip))
        {
            return true;
        }

        // Fetch from database
        if (db_.read_trip(trip_id, trip))
        {
            cache_.put_trip(trip_id, trip);
            return true;
        }

        return false;
    }

    // ========================================================================
    // ANALYTICS
    // ========================================================================

    struct TripStatistics
    {
        uint64_t total_trips;
        double total_distance;
        double total_duration;
        double avg_speed;
        double max_speed;
        double total_fuel;
        double avg_fuel_efficiency;
        uint32_t total_harsh_events;
        uint32_t safety_score;
    };

    TripStatistics get_driver_statistics(uint64_t driver_id)
    {
        TripStatistics stats = {};

        auto trips = db_.get_trips_by_driver(driver_id, 10000);

        for (const auto &trip : trips)
        {
            stats.total_trips++;
            stats.total_distance += trip.distance;
            stats.total_duration += trip.duration;
            stats.total_fuel += trip.fuel_consumed;

            if (trip.max_speed > stats.max_speed)
            {
                stats.max_speed = trip.max_speed;
            }

            stats.total_harsh_events += trip.harsh_braking_count +
                                        trip.rapid_acceleration_count +
                                        trip.speeding_count +
                                        trip.sharp_turn_count;
        }

        if (stats.total_trips > 0 && stats.total_duration > 0)
        {
            stats.avg_speed = (stats.total_distance / stats.total_duration) * 3600;
        }
        else
        {
            stats.avg_speed = 0;
        }

        if (stats.total_fuel > 0 && stats.total_distance > 0)
        {
            stats.avg_fuel_efficiency = stats.total_distance / stats.total_fuel;
        }
        else
        {
            stats.avg_fuel_efficiency = 0;
        }

        // Calculate safety score (0-1000)
        stats.safety_score = calculate_safety_score(stats);

        return stats;
    }

    // ========================================================================
    // HELPER FUNCTIONS
    // ========================================================================

private:
    uint64_t generate_trip_id()
    {
        static uint64_t counter = 1;
        return counter++;
    }

    uint64_t get_current_timestamp()
    {
        return std::chrono::system_clock::now().time_since_epoch().count();
    }

    // Haversine formula for distance calculation
    double calculate_distance(double lat1, double lon1, double lat2, double lon2)
    {
        double dLat = (lat2 - lat1) * M_PI / 180.0;
        double dLon = (lon2 - lon1) * M_PI / 180.0;

        lat1 = lat1 * M_PI / 180.0;
        lat2 = lat2 * M_PI / 180.0;

        double a = sin(dLat / 2) * sin(dLat / 2) +
                   sin(dLon / 2) * sin(dLon / 2) * cos(lat1) * cos(lat2);
        double c = 2 * atan2(sqrt(a), sqrt(1 - a));

        return EARTH_RADIUS_KM * c;
    }

    double calculate_heading_change(const GPSWaypoint &p1, const GPSWaypoint &p2)
    {
        double dLon = (p2.longitude - p1.longitude) * M_PI / 180.0;
        double lat1 = p1.latitude * M_PI / 180.0;
        double lat2 = p2.latitude * M_PI / 180.0;

        double y = sin(dLon) * cos(lat2);
        double x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);

        return atan2(y, x) * 180.0 / M_PI;
    }

    double estimate_fuel_consumption(const TripRecord &trip)
    {
        // Simplified fuel consumption model
        // Real implementation would use vehicle specs and driving patterns

        double base_consumption = trip.distance * 0.08; // 8L/100km base

        // Penalties for harsh driving
        double harsh_penalty = (trip.harsh_braking_count * 0.05 +
                                trip.rapid_acceleration_count * 0.05 +
                                trip.speeding_count * 0.02) *
                               0.1;

        return base_consumption * (1.0 + harsh_penalty);
    }

    uint32_t calculate_safety_score(const TripStatistics &stats)
    {
        uint32_t base_score = 1000;

        if (stats.total_distance > 0)
        {
            // Deduct points for harsh events per 100km
            double events_per_100km = (stats.total_harsh_events / stats.total_distance) * 100;
            uint32_t deduction = events_per_100km * 10;

            base_score = (base_score > deduction) ? (base_score - deduction) : 0;
        }

        return base_score;
    }

    void update_driver_stats(const TripRecord &trip)
    {
        DriverProfile driver;
        if (db_.read_driver(trip.driver_id, driver))
        {
            driver.total_trips++;
            driver.total_distance += trip.distance;
            driver.total_fuel_consumed += trip.fuel_consumed;
            driver.harsh_events_count += trip.harsh_braking_count +
                                         trip.rapid_acceleration_count +
                                         trip.speeding_count;

            // Recalculate safety score
            TripStatistics stats;
            stats.total_trips = driver.total_trips;
            stats.total_distance = driver.total_distance;
            stats.total_harsh_events = driver.harsh_events_count;
            driver.safety_score = calculate_safety_score(stats);

            db_.update_driver(driver);
            cache_.invalidate_driver(trip.driver_id);
        }
    }
};

#endif // TRIPMANAGER_H
#ifndef SESSIONMANAGER_H
#define SESSIONMANAGER_H

#include "../../include/sdm_types.hpp"
#include "SecurityManager.h"
#include "CacheManager.h"
#include "DatabaseManager.h"
#include "../../source/data_structures/Map.h"
#include <string>
#include <chrono>
#include <iostream>

using namespace std;

class SessionManager {
private:
    SecurityManager& security_;
    CacheManager& cache_;
    DatabaseManager& db_;
    uint32_t session_timeout_;
    Map<uint64_t, vector<string>> driver_sessions_;
    
public:
    SessionManager(SecurityManager& security, CacheManager& cache, 
                   DatabaseManager& db, uint32_t timeout = 1800)
        : security_(security), cache_(cache), db_(db), session_timeout_(timeout) {}
    
    bool login(const string& username, const string& password, 
               string& session_id, DriverProfile& driver) {
        DriverProfile found_driver;
        bool found = false;
        
        auto all_drivers = db_.get_all_drivers();
        for (const auto& d : all_drivers) {
            if (string(d.username) == username) {
                found_driver = d;
                found = true;
                break;
            }
        }
        
        if (!found) {
            return false;
        }
        
        string password_hash = security_.hash_password(password);
        if (string(found_driver.password_hash) != password_hash) {
            return false;
        }
        
        session_id = security_.generate_session_id();
        
        SessionInfo session;
        strncpy(session.session_id, session_id.c_str(), sizeof(session.session_id) - 1);
        session.driver_id = found_driver.driver_id;
        session.login_time = chrono::system_clock::now().time_since_epoch().count();
        session.last_activity = session.login_time;
        session.operations_count = 0;
        
        cache_.put_session(session_id, session);
        
        found_driver.last_login = session.login_time;
        db_.update_driver(found_driver);
        
        cache_.put_driver(found_driver.driver_id, found_driver);
        
        vector<string>* sessions = driver_sessions_.find(found_driver.driver_id);
        if (sessions) {
            sessions->push_back(session_id);
        } else {
            vector<string> new_sessions;
            new_sessions.push_back(session_id);
            driver_sessions_.insert(found_driver.driver_id, new_sessions);
        }
        
        driver = found_driver;
        return true;
    }
    
    bool logout(const string& session_id) {
        SessionInfo session;
        if (cache_.get_session(session_id, session)) {
            uint64_t driver_id = session.driver_id;
            
            vector<string>* sessions = driver_sessions_.find(driver_id);
            if (sessions) {
                auto it = find(sessions->begin(), sessions->end(), session_id);
                if (it != sessions->end()) {
                    sessions->erase(it);
                }
                if (sessions->empty()) {
                    driver_sessions_.erase(driver_id);
                }
            }
        }
        
        cache_.invalidate_session(session_id);
        return true;
    }
    
    bool validate_session(const string& session_id, SessionInfo& session) {
        if (!security_.is_valid_session_id(session_id)) {
            return false;
        }
        
        if (!cache_.get_session(session_id, session)) {
            return false;
        }
        
        session.last_activity = chrono::system_clock::now().time_since_epoch().count();
        cache_.put_session(session_id, session);
        
        return true;
    }
    
    bool get_driver_from_session(const string& session_id, DriverProfile& driver) {
        SessionInfo session;
        if (!validate_session(session_id, session)) {
            return false;
        }
        
        if (cache_.get_driver(session.driver_id, driver)) {
            return true;
        }
        
        if (db_.read_driver(session.driver_id, driver)) {
            cache_.put_driver(session.driver_id, driver);
            return true;
        }
        
        return false;
    }
    
    void increment_operation_count(const string& session_id) {
        SessionInfo session;
        if (cache_.get_session(session_id, session)) {
            session.operations_count++;
            cache_.put_session(session_id, session);
        }
    }
    
    bool is_admin(const string& session_id) {
        DriverProfile driver;
        if (get_driver_from_session(session_id, driver)) {
            return driver.role == UserRole::ADMIN;
        }
        return false;
    }
    
    bool is_fleet_manager(const string& session_id) {
        DriverProfile driver;
        if (get_driver_from_session(session_id, driver)) {
            return driver.role == UserRole::FLEET_MANAGER;
        }
        return false;
    }
    
    bool register_user(const string& username, const string& password,
                      const string& full_name, const string& email,
                      const string& phone, UserRole role = UserRole::DRIVER) {
        auto all_drivers = db_.get_all_drivers();
        for (const auto& d : all_drivers) {
            if (string(d.username) == username) {
                return false;
            }
        }
        
        DriverProfile new_driver;
        new_driver.driver_id = all_drivers.size() + 1;
        
        strncpy(new_driver.username, username.c_str(), sizeof(new_driver.username) - 1);
        strncpy(new_driver.full_name, full_name.c_str(), sizeof(new_driver.full_name) - 1);
        strncpy(new_driver.email, email.c_str(), sizeof(new_driver.email) - 1);
        strncpy(new_driver.phone, phone.c_str(), sizeof(new_driver.phone) - 1);
        
        string password_hash = security_.hash_password(password);
        strncpy(new_driver.password_hash, password_hash.c_str(), sizeof(new_driver.password_hash) - 1);
        
        new_driver.role = role;
        new_driver.is_active = 1;
        new_driver.created_time = chrono::system_clock::now().time_since_epoch().count();
        new_driver.safety_score = 1000;
        
        return db_.create_driver(new_driver);
    }
    
    bool change_password(const string& session_id, 
                        const string& old_password,
                        const string& new_password) {
        DriverProfile driver;
        if (!get_driver_from_session(session_id, driver)) {
            return false;
        }
        
        string old_hash = security_.hash_password(old_password);
        if (string(driver.password_hash) != old_hash) {
            return false;
        }
        
        string new_hash = security_.hash_password(new_password);
        strncpy(driver.password_hash, new_hash.c_str(), sizeof(driver.password_hash) - 1);
        
        bool success = db_.update_driver(driver);
        
        if (success) {
            cache_.put_driver(driver.driver_id, driver, true);
        }
        
        return success;
    }
    
    bool reset_password_admin(uint64_t driver_id, const string& new_password,
                             const string& admin_session_id) {
        if (!is_admin(admin_session_id)) {
            return false;
        }
        
        DriverProfile driver;
        if (!db_.read_driver(driver_id, driver)) {
            return false;
        }
        
        string new_hash = security_.hash_password(new_password);
        strncpy(driver.password_hash, new_hash.c_str(), sizeof(driver.password_hash) - 1);
        
        bool success = db_.update_driver(driver);
        
        if (success) {
            cache_.invalidate_driver(driver_id);
        }
        
        return success;
    }
    
    void cleanup_expired_sessions() {
        cache_.clear_expired_sessions();
    }
    
    void logout_all_driver_sessions(uint64_t driver_id) {
        vector<string>* sessions = driver_sessions_.find(driver_id);
        if (sessions) {
            for (const auto& session_id : *sessions) {
                cache_.invalidate_session(session_id);
            }
            driver_sessions_.erase(driver_id);
        }
    }
    
    size_t get_active_session_count(uint64_t driver_id) const {
        vector<string> sessions;
        if (driver_sessions_.get(driver_id, sessions)) {
            return sessions.size();
        }
        return 0;
    }
    
    vector<string> get_driver_sessions(uint64_t driver_id) const {
        vector<string> sessions;
        driver_sessions_.get(driver_id, sessions);
        return sessions;
    }
    
    void cleanup_expired_and_orphaned() {
        cleanup_expired_sessions();
        
        vector<uint64_t> drivers_to_clean;
        
        for (auto it = driver_sessions_.begin(); it != driver_sessions_.end(); ++it) {
            auto pair = *it;
            uint64_t driver_id = pair.first;
            vector<string> sessions = pair.second;
            
            vector<string> valid_sessions;
            for (const auto& session_id : sessions) {
                SessionInfo session;
                if (cache_.get_session(session_id, session)) {
                    valid_sessions.push_back(session_id);
                }
            }
            
            if (valid_sessions.empty()) {
                drivers_to_clean.push_back(driver_id);
            } else {
                driver_sessions_.insert(driver_id, valid_sessions);
            }
        }
        
        for (uint64_t driver_id : drivers_to_clean) {
            driver_sessions_.erase(driver_id);
        }
    }
};

#endif
#ifndef SECURITYMANAGER_H
#define SECURITYMANAGER_H

#include <string>
#include <cstdint>
#include <random>
#include <openssl/sha.h>
#include <openssl/evp.h>
#include <sstream>
#include <iomanip>
#include <iostream>
using namespace std;


class SecurityManager
{
private:
    mt19937_64 rng_;

public:
    SecurityManager()
    {
        random_device rd;
        rng_.seed(rd());
    }
    string hash_password(const string &password)
    {
        unsigned char hash[SHA256_DIGEST_LENGTH];


        EVP_MD_CTX *mdctx = EVP_MD_CTX_new();
        const EVP_MD *md = EVP_sha256();

        if (!mdctx || !md)
        {
            if (mdctx)
                EVP_MD_CTX_free(mdctx);
            return "";
        }

        EVP_DigestInit_ex(mdctx, md, NULL);
        EVP_DigestUpdate(mdctx, password.c_str(), password.length());
        EVP_DigestFinal_ex(mdctx, hash, NULL);
        EVP_MD_CTX_free(mdctx);

        stringstream ss;
        ss << hex << setfill('0');
        for (int i = 0; i < SHA256_DIGEST_LENGTH; i++)
        {
            ss << setw(2) << static_cast<int>(hash[i]);
        }

        string result = ss.str();

        if (result.length() != 64)
        {
            cerr << "[ERROR] Hash length incorrect: " << result.length()
                      << " (expected 64)" << endl;
        }

        return result;
    }
    bool verify_password(const string &password, const string &hash)
    {
        return hash_password(password) == hash;
    }
    string generate_session_id()
    {
        const char *hex_chars = "0123456789abcdef";
        string session_id;
        session_id.reserve(64);

        uniform_int_distribution<> dis(0, 15);
        for (int i = 0; i < 64; i++)
        {
            session_id += hex_chars[dis(rng_)];
        }

        return session_id;
    }
    void encrypt_data(const char *input, char *output, size_t size, const char *key, size_t key_len)
    {
        for (size_t i = 0; i < size; i++)
        {
            output[i] = input[i] ^ key[i % key_len];
        }
    }
    void decrypt_data(const char *input, char *output, size_t size, const char *key, size_t key_len)
    {
        encrypt_data(input, output, size, key, key_len);
    }
    bool is_valid_session_id(const string &session_id)
    {
        if (session_id.length() != 64)
            return false;

        for (char c : session_id)
        {
            if (!((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')))
            {
                return false;
            }
        }

        return true;
    }
};

#endif 
#ifndef INDEXMANAGER_H
#define INDEXMANAGER_H

#include "../../source/data_structures/BTree.h"
#include "../../source/data_structures/BPlusTree.h"
#include "../../include/sdm_types.hpp"
#include <memory>
#include <string>
#include <sys/stat.h>
#include <iostream>
using namespace std;


class IndexManager
{
private:
    unique_ptr<BTree> primary_index_;
    
    unique_ptr<BPlusTree> driver_email_index_;
    unique_ptr<BPlusTree> vehicle_plate_index_;
    unique_ptr<BPlusTree> driver_username_index_;

    string index_dir_;

    bool ensure_directory_exists(const string& path) {
        struct stat st;
        if (stat(path.c_str(), &st) != 0) {
            cout << "      Creating index directory: " << path << endl;
            string cmd = "mkdir -p \"" + path + "\"";
            if (system(cmd.c_str()) != 0) {
                cerr << "      ERROR: Failed to create directory!" << endl;
                return false;
            }
        }
        return true;
    }

public:
    IndexManager(const string &index_dir) : index_dir_(index_dir) {}

    ~IndexManager()
    {
        close_all();
    }

    bool create_indexes()
    {
        cout << "      Creating primary B-Tree index..." << flush;
        primary_index_ = make_unique<BTree>(index_dir_ + "/primary.idx");
        if (!primary_index_->create()) {
            cerr << endl << "      ERROR: Failed to create primary index!" << endl;
            return false;
        }
        if (!primary_index_->open()) {
            cerr << endl << "      ERROR: Failed to open primary index!" << endl;
            return false;
        }
        cout << " ✓" << endl;

        cout << "      Creating driver email B+ Tree..." << flush;
        driver_email_index_ = make_unique<BPlusTree>(
            index_dir_ + "/driver_email.idx", "driver_email");
        if (!driver_email_index_->create()) {
            cerr << endl << "      ERROR: Failed to create email index!" << endl;
            return false;
        }
        if (!driver_email_index_->open()) {
            cerr << endl << "      ERROR: Failed to open email index!" << endl;
            return false;
        }
        cout << " ✓" << endl;

        cout << "      Creating vehicle plate B+ Tree..." << flush;
        vehicle_plate_index_ = make_unique<BPlusTree>(
            index_dir_ + "/vehicle_plate.idx", "vehicle_plate");
        if (!vehicle_plate_index_->create()) {
            cerr << endl << "      ERROR: Failed to create plate index!" << endl;
            return false;
        }
        if (!vehicle_plate_index_->open()) {
            cerr << endl << "      ERROR: Failed to open plate index!" << endl;
            return false;
        }
        cout << " ✓" << endl;

        cout << "      Creating driver username B+ Tree..." << flush;
        driver_username_index_ = make_unique<BPlusTree>(
            index_dir_ + "/driver_username.idx", "driver_username");
        if (!driver_username_index_->create()) {
            cerr << endl << "      ERROR: Failed to create username index!" << endl;
            return false;
        }
        if (!driver_username_index_->open()) {
            cerr << endl << "      ERROR: Failed to open username index!" << endl;
            return false;
        }
        cout << " ✓" << endl;

        return true;
    }

    bool open_indexes()
    {
        cout << "      Opening primary index..." << flush;
        primary_index_ = make_unique<BTree>(index_dir_ + "/primary.idx");
        if (!primary_index_->open()) {
            cout << " NOT FOUND" << endl;
            return false;
        }
        cout << " ✓" << endl;

        cout << "      Opening email index..." << flush;
        driver_email_index_ = make_unique<BPlusTree>(
            index_dir_ + "/driver_email.idx", "driver_email");
        if (!driver_email_index_->open()) {
            cout << " NOT FOUND" << endl;
            return false;
        }
        cout << " ✓" << endl;

        cout << "      Opening plate index..." << flush;
        vehicle_plate_index_ = make_unique<BPlusTree>(
            index_dir_ + "/vehicle_plate.idx", "vehicle_plate");
        if (!vehicle_plate_index_->open()) {
            cout << " NOT FOUND" << endl;
            return false;
        }
        cout << " ✓" << endl;

        cout << "      Opening username index..." << flush;
        driver_username_index_ = make_unique<BPlusTree>(
            index_dir_ + "/driver_username.idx", "driver_username");
        if (!driver_username_index_->open()) {
            cout << " NOT FOUND" << endl;
            return false;
        }
        cout << " ✓" << endl;

        return true;
    }

    void close_all()
    {
        if (primary_index_)
            primary_index_->close();
        if (driver_email_index_)
            driver_email_index_->close();
        if (vehicle_plate_index_)
            vehicle_plate_index_->close();
        if (driver_username_index_)
            driver_username_index_->close();
    }

    bool insert_primary(uint8_t entity_type, uint64_t entity_id,
                        uint64_t timestamp, uint64_t record_offset)
    {
        if (!primary_index_)
            return false;

        CompositeKey key(entity_type, entity_id, timestamp, 0);
        BTreeValue value(record_offset, 1, 1024);

        return primary_index_->insert(key, value);
    }

    bool search_primary(uint8_t entity_type, uint64_t entity_id,
                        uint64_t timestamp, uint64_t &record_offset)
    {
        if (!primary_index_)
            return false;

        CompositeKey key(entity_type, entity_id, timestamp, 0);
        BTreeValue value;

        if (primary_index_->search(key, value))
        {
            record_offset = value.record_offset;
            return true;
        }

        return false;
    }

    vector<uint64_t> range_query_primary(uint8_t entity_type, uint64_t entity_id,
                                              uint64_t start_time, uint64_t end_time)
    {
        vector<uint64_t> offsets;
        if (!primary_index_)
            return offsets;

        CompositeKey start_key(entity_type, entity_id, start_time, 0);
        CompositeKey end_key(entity_type, entity_id, end_time, UINT32_MAX);

        auto results = primary_index_->range_query(start_key, end_key);

        for (const auto &result : results)
        {
            offsets.push_back(result.second.record_offset);
        }

        return offsets;
    }

    bool insert_driver_email(const string &email, uint64_t driver_id)
    {
        if (!driver_email_index_)
            return false;

        BPlusKey key(email);
        BPlusValue value(driver_id, 1);
        return driver_email_index_->insert(key, value);
    }

    bool search_by_email(const string &email, uint64_t &driver_id)
    {
        if (!driver_email_index_)
            return false;

        BPlusKey key(email);
        BPlusValue value;

        if (driver_email_index_->search(key, value))
        {
            driver_id = value.primary_id;
            return true;
        }

        return false;
    }

    bool insert_driver_username(const string &username, uint64_t driver_id)
    {
        if (!driver_username_index_)
            return false;

        BPlusKey key(username);
        BPlusValue value(driver_id, 1);

        return driver_username_index_->insert(key, value);
    }

    bool search_by_username(const string &username, uint64_t &driver_id)
    {
        if (!driver_username_index_)
            return false;

        BPlusKey key(username);
        BPlusValue value;

        if (driver_username_index_->search(key, value))
        {
            driver_id = value.primary_id;
            return true;
        }

        return false;
    }

    bool insert_vehicle_plate(const string &plate, uint64_t vehicle_id)
    {
        if (!vehicle_plate_index_)
            return false;

        BPlusKey key(plate);
        BPlusValue value(vehicle_id, 2);

        return vehicle_plate_index_->insert(key, value);
    }

    bool search_by_plate(const string &plate, uint64_t &vehicle_id)
    {
        if (!vehicle_plate_index_)
            return false;

        BPlusKey key(plate);
        BPlusValue value;

        if (vehicle_plate_index_->search(key, value))
        {
            vehicle_id = value.primary_id;
            return true;
        }

        return false;
    }

    bool rebuild_driver_indexes(const vector<DriverProfile> &drivers)
    {
        for (const auto &driver : drivers)
        {
            insert_driver_email(driver.email, driver.driver_id);
            insert_driver_username(driver.username, driver.driver_id);
        }
        return true;
    }

    bool rebuild_vehicle_indexes(const vector<VehicleInfo> &vehicles)
    {
        for (const auto &vehicle : vehicles)
        {
            insert_vehicle_plate(vehicle.license_plate, vehicle.vehicle_id);
        }
        return true;
    }

    uint64_t get_primary_record_count() const
    {
        return primary_index_ ? primary_index_->get_total_records() : 0;
    }

    uint64_t get_driver_email_count() const
    {
        return driver_email_index_ ? driver_email_index_->get_total_entries() : 0;
    }

    uint64_t get_vehicle_plate_count() const
    {
        return vehicle_plate_index_ ? vehicle_plate_index_->get_total_entries() : 0;
    }
};

#endif
#ifndef INCIDENTMANAGER_H
#define INCIDENTMANAGER_H

#include "../../include/sdm_types.hpp"
#include "DatabaseManager.h"
#include "CacheManager.h"
#include <vector>
#include<iostream>
#include <string>
using namespace std;

class IncidentManager {
private:
    DatabaseManager& db_;
    CacheManager& cache_;
    
    vector<IncidentReport> incidents_;
    uint64_t next_incident_id_;

    void update_driver_safety_after_incident(uint64_t driver_id, IncidentType type) {
        DriverProfile driver;
        if (!db_.read_driver(driver_id, driver)) {
            return;
        }
        
        uint32_t deduction = 0;
        switch(type) {
            case IncidentType::ACCIDENT:
                deduction = 150;
                cout << "\nSAFETY IMPACT: -150 points (Accident)" << endl;
                break;
            case IncidentType::BREAKDOWN:
                deduction = 0;
                break;
            case IncidentType::THEFT:
                deduction = 0;
                break;
            case IncidentType::VANDALISM:
                deduction = 0;
                break;
            case IncidentType::TRAFFIC_VIOLATION:
                deduction = 100;
                cout << "\nSAFETY IMPACT: -100 points (Traffic Violation)" << endl;
                break;
            default:
                deduction = 50;
                break;
        }
        
        if (driver.safety_score > deduction) {
            driver.safety_score -= deduction;
        } else {
            driver.safety_score = 0;
        }
        
        db_.update_driver(driver);
        cache_.invalidate_driver(driver_id);
        
        cout << "New Safety Score: " << driver.safety_score << "/1000" << endl;
    }

public:
    IncidentManager(DatabaseManager& db, CacheManager& cache)
        : db_(db), cache_(cache) {}
    
    uint64_t report_incident(uint64_t driver_id,
                            uint64_t vehicle_id,
                            IncidentType type,
                            double latitude,
                            double longitude,
                            const string& location_address,
                            const string& description,
                            uint64_t trip_id = 0) {
        uint64_t incident_id = next_incident_id_++;
        
        IncidentReport incident;
        incident.incident_id = incident_id;
        incident.driver_id = driver_id;
        incident.vehicle_id = vehicle_id;
        incident.trip_id = trip_id;
        incident.type = type;
        incident.incident_time = get_current_timestamp();
        incident.latitude = latitude;
        incident.longitude = longitude;
        strncpy(incident.location_address, location_address.c_str(), 
               sizeof(incident.location_address) - 1);
        strncpy(incident.description, description.c_str(), 
               sizeof(incident.description) - 1);
        incident.is_resolved = 0;
        
        incidents_.push_back(incident);
        
        
        update_driver_safety_after_incident(driver_id, type);
        
        return incident_id;
    }
    
    uint64_t report_accident(uint64_t driver_id, uint64_t vehicle_id,
                            double latitude, double longitude,
                            const string& description,
                            const string& other_party_info = "",
                            double estimated_damage = 0.0) {
        uint64_t incident_id = report_incident(driver_id, vehicle_id,
            IncidentType::ACCIDENT, latitude, longitude, "", description);
        
        
        for (auto& inc : incidents_) {
            if (inc.incident_id == incident_id) {
                strncpy(inc.other_party_info, other_party_info.c_str(), 
                       sizeof(inc.other_party_info) - 1);
                inc.estimated_damage = estimated_damage;
                break;
            }
        }
        
        return incident_id;
    }
    
    uint64_t report_breakdown(uint64_t driver_id, uint64_t vehicle_id,
                             double latitude, double longitude,
                             const string& issue_description) {
        return report_incident(driver_id, vehicle_id, IncidentType::BREAKDOWN,
                             latitude, longitude, "", issue_description);
    }
    
    uint64_t report_theft(uint64_t driver_id, uint64_t vehicle_id,
                         double latitude, double longitude,
                         const string& description,
                         const string& police_report_number) {
        uint64_t incident_id = report_incident(driver_id, vehicle_id,
            IncidentType::THEFT, latitude, longitude, "", description);
        
        for (auto& inc : incidents_) {
            if (inc.incident_id == incident_id) {
                strncpy(inc.police_report_number, police_report_number.c_str(),
                       sizeof(inc.police_report_number) - 1);
                break;
            }
        }
        
        return incident_id;
    }
    
    bool add_police_report(uint64_t incident_id, const string& report_number) {
        for (auto& inc : incidents_) {
            if (inc.incident_id == incident_id) {
                strncpy(inc.police_report_number, report_number.c_str(),
                       sizeof(inc.police_report_number) - 1);
                return true;
            }
        }
        return false;
    }
    
    bool add_insurance_claim(uint64_t incident_id,
                            const string& claim_number,
                            double payout_amount) {
        for (auto& inc : incidents_) {
            if (inc.incident_id == incident_id) {
                strncpy(inc.insurance_claim_number, claim_number.c_str(),
                       sizeof(inc.insurance_claim_number) - 1);
                inc.insurance_payout = payout_amount;
                return true;
            }
        }
        return false;
    }
    
    
    bool mark_resolved(uint64_t incident_id) {
        for (auto& inc : incidents_) {
            if (inc.incident_id == incident_id) {
                inc.is_resolved = 1;
                inc.resolved_date = get_current_timestamp();
                return true;
            }
        }
        return false;
    }
    
    vector<IncidentReport> get_driver_incidents(uint64_t driver_id) {
        vector<IncidentReport> result;
        for (const auto& inc : incidents_) {
            if (inc.driver_id == driver_id) {
                result.push_back(inc);
            }
        }
        return result;
    }
    
    vector<IncidentReport> get_vehicle_incidents(uint64_t vehicle_id) {
        vector<IncidentReport> result;
        for (const auto& inc : incidents_) {
            if (inc.vehicle_id == vehicle_id) {
                result.push_back(inc);
            }
        }
        return result;
    }
    
    vector<IncidentReport> get_unresolved_incidents(uint64_t driver_id) {
        vector<IncidentReport> result;
        for (const auto& inc : incidents_) {
            if (inc.driver_id == driver_id && inc.is_resolved == 0) {
                result.push_back(inc);
            }
        }
        return result;
    }
    
    vector<IncidentReport> get_incidents_by_type(uint64_t driver_id,
                                                      IncidentType type) {
        vector<IncidentReport> result;
        for (const auto& inc : incidents_) {
            if (inc.driver_id == driver_id && inc.type == type) {
                result.push_back(inc);
            }
        }
        return result;
    }
    
    struct IncidentStats {
        uint64_t driver_id;
        uint32_t total_incidents;
        uint32_t total_accidents;
        uint32_t total_breakdowns;
        uint32_t total_thefts;
        uint32_t total_violations;
        uint32_t resolved_incidents;
        uint32_t unresolved_incidents;
        double total_damage_cost;
        double total_insurance_payout;
        uint32_t incident_free_days;
    };
    
    IncidentStats get_incident_statistics(uint64_t driver_id) {
        IncidentStats stats = {};
        stats.driver_id = driver_id;
        
        auto incidents = get_driver_incidents(driver_id);
        
        uint64_t last_incident_time = 0;
        
        for (const auto& incident : incidents) {
            stats.total_incidents++;
            
            switch(incident.type) {
                case IncidentType::ACCIDENT:
                    stats.total_accidents++;
                    break;
                case IncidentType::BREAKDOWN:
                    stats.total_breakdowns++;
                    break;
                case IncidentType::THEFT:
                    stats.total_thefts++;
                    break;
                case IncidentType::TRAFFIC_VIOLATION:
                    stats.total_violations++;
                    break;
                default:
                    break;
            }
            
            if (incident.is_resolved) {
                stats.resolved_incidents++;
            } else {
                stats.unresolved_incidents++;
            }
            
            stats.total_damage_cost += incident.estimated_damage;
            stats.total_insurance_payout += incident.insurance_payout;
            
            if (incident.incident_time > last_incident_time) {
                last_incident_time = incident.incident_time;
            }
        }
        
        if (last_incident_time > 0) {
            uint64_t current_time = get_current_timestamp();
            uint64_t days_since = (current_time - last_incident_time) / 
                                 (86400ULL * 1000000000ULL);
            stats.incident_free_days = days_since;
        }
        
        return stats;
    }
    
private:
    uint64_t get_current_timestamp() {
        return chrono::system_clock::now().time_since_epoch().count();
    }
};

#endif
// File Location: source/modules/ExpenseManager.h
// Smart Drive Manager - Expense & Budget Tracking

#ifndef EXPENSEMANAGER_H
#define EXPENSEMANAGER_H

#include "../../include/sdm_types.hpp"
#include "../../source/core/DatabaseManager.h"
#include "../../source/core/CacheManager.h"
#include "../../source/core/IndexManager.h"
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iostream>
using namespace std;


class ExpenseManager
{
private:
    DatabaseManager &db_;
    CacheManager &cache_;
    IndexManager &index_;

    struct BudgetLimit
    {
        uint64_t driver_id;
        ExpenseCategory category;
        double monthly_limit;
        double current_month_spent;
        uint64_t alert_threshold_percentage; 
    };

    vector<BudgetLimit> budget_limits_;

public:
    ExpenseManager(DatabaseManager &db, CacheManager &cache, IndexManager &index)
        : db_(db), cache_(cache), index_(index) {}


    uint64_t add_expense(uint64_t driver_id,
                         uint64_t vehicle_id,
                         ExpenseCategory category,
                         double amount,
                         const string &description,
                         uint64_t trip_id = 0)
    {
        uint64_t expense_id = generate_expense_id();

        ExpenseRecord expense;
        expense.expense_id = expense_id;
        expense.driver_id = driver_id;
        expense.vehicle_id = vehicle_id;
        expense.trip_id = trip_id;
        expense.category = category;
        expense.expense_date = get_current_timestamp();
        expense.amount = amount;
        strncpy(expense.currency, "USD", sizeof(expense.currency) - 1);
        strncpy(expense.description, description.c_str(), sizeof(expense.description) - 1);

        if (!db_.create_expense(expense))
        {
            return 0;
        }

        index_.insert_primary(4, expense_id, expense.expense_date, 0); 

        check_budget_alert(driver_id, category, amount);

        cache_.clear_query_cache();

        return expense_id;
    }

    uint64_t add_fuel_expense(uint64_t driver_id,
                              uint64_t vehicle_id,
                              uint64_t trip_id,
                              double fuel_quantity,
                              double price_per_unit,
                              const string &station)
    {
        uint64_t expense_id = generate_expense_id();

        ExpenseRecord expense;
        expense.expense_id = expense_id;
        expense.driver_id = driver_id;
        expense.vehicle_id = vehicle_id;
        expense.trip_id = trip_id;
        expense.category = ExpenseCategory::FUEL;
        expense.expense_date = get_current_timestamp();
        expense.fuel_quantity = fuel_quantity;
        expense.fuel_price_per_unit = price_per_unit;
        expense.amount = fuel_quantity * price_per_unit;
        strncpy(expense.currency, "USD", sizeof(expense.currency) - 1);
        strncpy(expense.fuel_station, station.c_str(), sizeof(expense.fuel_station) - 1);

        string desc = "Fuel: " + to_string(fuel_quantity) + "L at " + station;
        strncpy(expense.description, desc.c_str(), sizeof(expense.description) - 1);

        if (!db_.create_expense(expense))
        {
            return 0;
        }

        index_.insert_primary(4, expense_id, expense.expense_date, 0);
        check_budget_alert(driver_id, ExpenseCategory::FUEL, expense.amount);
        cache_.clear_query_cache();

        return expense_id;
    }

    vector<ExpenseRecord> get_driver_expenses(uint64_t driver_id, int limit = 100)
    {
        return db_.get_expenses_by_driver(driver_id, limit);
    }

    vector<ExpenseRecord> get_expenses_by_category(uint64_t driver_id,
                                                        ExpenseCategory category)
    {
        return db_.get_expenses_by_category(driver_id, category);
    }

    vector<ExpenseRecord> get_expenses_by_date_range(uint64_t driver_id,
                                                          uint64_t start_date,
                                                          uint64_t end_date)
    {
        auto all_expenses = db_.get_expenses_by_driver(driver_id, 100000);

        vector<ExpenseRecord> filtered;
        for (const auto &expense : all_expenses)
        {
            if (expense.expense_date >= start_date && expense.expense_date <= end_date)
            {
                filtered.push_back(expense);
            }
        }

        return filtered;
    }

    bool set_budget_limit(uint64_t driver_id,
                          ExpenseCategory category,
                          double monthly_limit,
                          uint64_t alert_percentage = 80)
    {
        // Find existing budget or create new
        auto it = find_if(budget_limits_.begin(), budget_limits_.end(),
                               [driver_id, category](const BudgetLimit &b)
                               {
                                   return b.driver_id == driver_id && b.category == category;
                               });

        if (it != budget_limits_.end())
        {
            it->monthly_limit = monthly_limit;
            it->alert_threshold_percentage = alert_percentage;
        }
        else
        {
            BudgetLimit budget;
            budget.driver_id = driver_id;
            budget.category = category;
            budget.monthly_limit = monthly_limit;
            budget.current_month_spent = 0;
            budget.alert_threshold_percentage = alert_percentage;
            budget_limits_.push_back(budget);
        }

        return true;
    }

    bool get_budget_status(uint64_t driver_id, ExpenseCategory category,
                           double &limit, double &spent, double &remaining)
    {
        auto it = find_if(budget_limits_.begin(), budget_limits_.end(),
                               [driver_id, category](const BudgetLimit &b)
                               {
                                   return b.driver_id == driver_id && b.category == category;
                               });

        if (it == budget_limits_.end())
        {
            return false;
        }

        uint64_t month_start = get_month_start_timestamp();
        uint64_t month_end = get_current_timestamp();

        auto expenses = get_expenses_by_date_range(driver_id, month_start, month_end);

        double total_spent = 0;
        for (const auto &expense : expenses)
        {
            if (expense.category == category)
            {
                total_spent += expense.amount;
            }
        }

        limit = it->monthly_limit;
        spent = total_spent;
        remaining = limit - spent;

        return true;
    }

    struct BudgetAlert
    {
        uint64_t driver_id;
        ExpenseCategory category;
        double limit;
        double spent;
        double percentage_used;
        bool over_budget;
    };

    vector<BudgetAlert> get_budget_alerts(uint64_t driver_id)
    {
        vector<BudgetAlert> alerts;

        for (const auto &budget : budget_limits_)
        {
            if (budget.driver_id != driver_id)
                continue;

            double limit, spent, remaining;
            if (get_budget_status(driver_id, budget.category, limit, spent, remaining))
            {
                double percentage = (spent / limit) * 100.0;

                if (percentage >= budget.alert_threshold_percentage || spent > limit)
                {
                    BudgetAlert alert;
                    alert.driver_id = driver_id;
                    alert.category = budget.category;
                    alert.limit = limit;
                    alert.spent = spent;
                    alert.percentage_used = percentage;
                    alert.over_budget = (spent > limit);
                    alerts.push_back(alert);
                }
            }
        }

        return alerts;
    }

    struct ExpenseSummary
    {
        double total_expenses;
        double fuel_expenses;
        double maintenance_expenses;
        double insurance_expenses;
        double toll_expenses;
        double parking_expenses;
        double other_expenses;

        map<ExpenseCategory, double> by_category;
        map<uint64_t, double> by_vehicle; // vehicle_id -> amount

        double average_daily_expense;
        double average_monthly_expense;
        int total_transactions;
    };

    ExpenseSummary get_expense_summary(uint64_t driver_id,
                                       uint64_t start_date,
                                       uint64_t end_date)
    {
        ExpenseSummary summary = {};

        auto expenses = get_expenses_by_date_range(driver_id, start_date, end_date);

        for (const auto &expense : expenses)
        {
            summary.total_expenses += expense.amount;
            summary.total_transactions++;

            // Categorize
            switch (expense.category)
            {
            case ExpenseCategory::FUEL:
                summary.fuel_expenses += expense.amount;
                break;
            case ExpenseCategory::MAINTENANCE:
                summary.maintenance_expenses += expense.amount;
                break;
            case ExpenseCategory::INSURANCE:
                summary.insurance_expenses += expense.amount;
                break;
            case ExpenseCategory::TOLL:
                summary.toll_expenses += expense.amount;
                break;
            case ExpenseCategory::PARKING:
                summary.parking_expenses += expense.amount;
                break;
            default:
                summary.other_expenses += expense.amount;
                break;
            }

            summary.by_category[expense.category] += expense.amount;

            summary.by_vehicle[expense.vehicle_id] += expense.amount;
        }

        uint64_t days = (end_date - start_date) / (86400ULL * 1000000000ULL);
        if (days > 0)
        {
            summary.average_daily_expense = summary.total_expenses / days;
            summary.average_monthly_expense = summary.total_expenses / (days / 30.0);
        }

        return summary;
    }

    struct MonthlyExpenseReport
    {
        uint32_t year;
        uint32_t month;
        double total;
        map<ExpenseCategory, double> by_category;
    };

    vector<MonthlyExpenseReport> get_monthly_reports(uint64_t driver_id,
                                                          int num_months = 12)
    {
        vector<MonthlyExpenseReport> reports;

        // Get current date components
        auto current = get_current_timestamp();

        for (int i = 0; i < num_months; i++)
        {
            MonthlyExpenseReport report;

            // Calculate month start/end (simplified)
            uint64_t month_start = current - (i * 30ULL * 86400ULL * 1000000000ULL);
            uint64_t month_end = month_start + (30ULL * 86400ULL * 1000000000ULL);

            auto expenses = get_expenses_by_date_range(driver_id, month_start, month_end);

            report.total = 0;
            for (const auto &expense : expenses)
            {
                report.total += expense.amount;
                report.by_category[expense.category] += expense.amount;
            }

            reports.push_back(report);
        }

        reverse(reports.begin(), reports.end());
        return reports;
    }

    

    struct TaxReport
    {
        double total_deductible_expenses;
        double total_non_deductible;
        vector<ExpenseRecord> deductible_expenses;
        uint64_t start_date;
        uint64_t end_date;
    };

    TaxReport generate_tax_report(uint64_t driver_id,
                                  uint64_t start_date,
                                  uint64_t end_date)
    {
        TaxReport report;
        report.start_date = start_date;
        report.end_date = end_date;

        auto expenses = get_expenses_by_date_range(driver_id, start_date, end_date);

        for (const auto &expense : expenses)
        {
            if (expense.is_tax_deductible)
            {
                report.total_deductible_expenses += expense.amount;
                report.deductible_expenses.push_back(expense);
            }
            else
            {
                report.total_non_deductible += expense.amount;
            }
        }

        return report;
    }

    bool mark_expense_tax_deductible(uint64_t expense_id, bool deductible,
                                     double tax_amount = 0)
    {
        // Would need to update expense record
        // Simplified implementation
        return true;
    }

    struct CostPerKilometer
    {
        double total_distance;
        double total_cost;
        double cost_per_km;
        double fuel_cost_per_km;
        double maintenance_cost_per_km;
        double other_cost_per_km;
    };

    CostPerKilometer calculate_cost_per_km(uint64_t driver_id,
                                           uint64_t start_date,
                                           uint64_t end_date)
    {
        CostPerKilometer result = {};

        auto expenses = get_expenses_by_date_range(driver_id, start_date, end_date);

        double total_distance = 0;

        double fuel_cost = 0, maintenance_cost = 0, other_cost = 0;

        for (const auto &expense : expenses)
        {
            result.total_cost += expense.amount;

            switch (expense.category)
            {
            case ExpenseCategory::FUEL:
                fuel_cost += expense.amount;
                break;
            case ExpenseCategory::MAINTENANCE:
                maintenance_cost += expense.amount;
                break;
            default:
                other_cost += expense.amount;
                break;
            }
        }

        if (total_distance > 0)
        {
            result.total_distance = total_distance;
            result.cost_per_km = result.total_cost / total_distance;
            result.fuel_cost_per_km = fuel_cost / total_distance;
            result.maintenance_cost_per_km = maintenance_cost / total_distance;
            result.other_cost_per_km = other_cost / total_distance;
        }

        return result;
    }

private:
    uint64_t generate_expense_id()
    {
        static uint64_t counter = 1;
        return counter++;
    }

    uint64_t get_current_timestamp()
    {
        return chrono::system_clock::now().time_since_epoch().count();
    }

    uint64_t get_month_start_timestamp()
    {
        auto now = chrono::system_clock::now();
        auto time_t = chrono::system_clock::to_time_t(now);
        auto tm = *localtime(&time_t);
        tm.tm_mday = 1;
        tm.tm_hour = 0;
        tm.tm_min = 0;
        tm.tm_sec = 0;

        auto month_start = chrono::system_clock::from_time_t(mktime(&tm));
        return month_start.time_since_epoch().count();
    }

    void check_budget_alert(uint64_t driver_id, ExpenseCategory category, double amount)
    {
        auto it = find_if(budget_limits_.begin(), budget_limits_.end(),
                               [driver_id, category](const BudgetLimit &b)
                               {
                                   return b.driver_id == driver_id && b.category == category;
                               });

        if (it != budget_limits_.end())
        {
            it->current_month_spent += amount;
            
            double percentage = (it->current_month_spent / it->monthly_limit) * 100.0;

            if (percentage >= it->alert_threshold_percentage || it->current_month_spent > it->monthly_limit)
            {
                cout << "\n💰 BUDGET ALERT!" << endl;
                cout << "Category: " << get_category_name(category) << endl;
                cout << "Spent: $" << fixed << setprecision(2) 
                         << it->current_month_spent << " / $" << it->monthly_limit << endl;
                cout << "Usage: " << percentage << "%" << endl;
                
                if (it->current_month_spent > it->monthly_limit) {
                    cout << "⚠️  OVER BUDGET!" << endl;
                }
                cout << endl;
            }
        }
    }

    string get_category_name(ExpenseCategory category)
    {
        switch (category)
        {
        case ExpenseCategory::FUEL:
            return "Fuel";
        case ExpenseCategory::MAINTENANCE:
            return "Maintenance";
        case ExpenseCategory::INSURANCE:
            return "Insurance";
        case ExpenseCategory::TOLL:
            return "Toll";
        case ExpenseCategory::PARKING:
            return "Parking";
        default:
            return "Other";
        }
    }
};

#endif // EXPENSEMANAGER_H
// File Location: source/modules/DriverManager.h
// Smart Drive Manager - Driver Profile & Behavior Management

#ifndef DRIVERMANAGER_H
#define DRIVERMANAGER_H

#include "../../include/sdm_types.hpp"
#include "DatabaseManager.h"
#include "CacheManager.h"
#include "IndexManager.h"
#include <vector>
#include <algorithm>

class DriverManager
{
private:
    DatabaseManager &db_;
    CacheManager &cache_;
    IndexManager &index_;

public:
    DriverManager(DatabaseManager &db, CacheManager &cache, IndexManager &index)
        : db_(db), cache_(cache), index_(index) {}

    // ========================================================================
    // DRIVER PROFILE OPERATIONS
    // ========================================================================

    bool update_driver_profile(uint64_t driver_id,
                               const std::string &full_name,
                               const std::string &email,
                               const std::string &phone)
    {
        DriverProfile driver;
        if (!db_.read_driver(driver_id, driver))
        {
            return false;
        }

        strncpy(driver.full_name, full_name.c_str(), sizeof(driver.full_name) - 1);
        strncpy(driver.email, email.c_str(), sizeof(driver.email) - 1);
        strncpy(driver.phone, phone.c_str(), sizeof(driver.phone) - 1);

        if (db_.update_driver(driver))
        {
            cache_.invalidate_driver(driver_id);
            return true;
        }

        return false;
    }

    bool update_license_info(uint64_t driver_id,
                             const std::string &license_number,
                             uint64_t expiry_date)
    {
        DriverProfile driver;
        if (!db_.read_driver(driver_id, driver))
        {
            return false;
        }

        strncpy(driver.license_number, license_number.c_str(), sizeof(driver.license_number) - 1);
        driver.license_expiry = expiry_date;

        if (db_.update_driver(driver))
        {
            cache_.invalidate_driver(driver_id);
            return true;
        }

        return false;
    }

    bool get_driver_profile(uint64_t driver_id, DriverProfile &driver)
    {
        // Try cache first
        if (cache_.get_driver(driver_id, driver))
        {
            return true;
        }

        // Fetch from database
        if (db_.read_driver(driver_id, driver))
        {
            cache_.put_driver(driver_id, driver);
            return true;
        }

        return false;
    }

    // ========================================================================
    // DRIVER BEHAVIOR & SCORING
    // ========================================================================

    struct DriverBehaviorMetrics
    {
        uint64_t driver_id;
        uint32_t safety_score; // 0-1000

        // Trip statistics
        uint64_t total_trips;
        double total_distance;
        double total_duration; // hours

        // Driving events
        uint32_t harsh_braking_count;
        uint32_t rapid_acceleration_count;
        uint32_t speeding_violations;
        uint32_t sharp_turns;

        // Event rates (per 100km)
        double harsh_braking_rate;
        double acceleration_rate;
        double speeding_rate;

        // Fuel efficiency
        double avg_fuel_efficiency; // km/L

        // Speed statistics
        double avg_speed;
        double max_speed_recorded;

        // Time-of-day patterns
        uint32_t night_driving_trips; // 10pm - 6am
        uint32_t peak_hour_trips;     // 7-9am, 5-7pm

        // Vision analytics (if available)
        uint32_t drowsiness_events;
        uint32_t distraction_events;
        uint32_t collision_warnings;

        // Ranking
        uint32_t rank_in_fleet; // Position among all drivers
        double percentile;      // Top X%
    };

    DriverBehaviorMetrics get_driver_behavior(uint64_t driver_id)
    {
        DriverBehaviorMetrics metrics = {};
        metrics.driver_id = driver_id;

        DriverProfile driver;
        if (!get_driver_profile(driver_id, driver))
        {
            return metrics;
        }

        // Populate from driver profile
        metrics.safety_score = driver.safety_score;
        metrics.total_trips = driver.total_trips;
        metrics.total_distance = driver.total_distance;
        metrics.harsh_braking_count = driver.harsh_events_count;

        // Calculate rates
        if (metrics.total_distance > 0)
        {
            metrics.harsh_braking_rate = (metrics.harsh_braking_count / metrics.total_distance) * 100;
        }

        // Get ranking
        calculate_driver_ranking(driver_id, metrics);

        return metrics;
    }

    uint32_t calculate_safety_score(const DriverBehaviorMetrics &metrics)
    {
        uint32_t score = 1000; // Perfect score

        // Deduct for harsh events
        score -= std::min(score, (uint32_t)(metrics.harsh_braking_rate * 10));
        score -= std::min(score, (uint32_t)(metrics.acceleration_rate * 10));
        score -= std::min(score, (uint32_t)(metrics.speeding_rate * 15));

        // Deduct for vision-detected issues
        score -= std::min(score, metrics.drowsiness_events * 20);
        score -= std::min(score, metrics.distraction_events * 15);

        // Bonus for safe driving
        if (metrics.total_distance > 10000 && score > 900)
        {
            score += 50; // Experienced safe driver bonus
        }

        return std::min((uint32_t)1000, score);
    }

    // ========================================================================
    // DRIVER COMPARISON & RANKING
    // ========================================================================

    struct DriverRanking
    {
        uint64_t driver_id;
        std::string driver_name;
        uint32_t safety_score;
        double total_distance;
        uint32_t rank;
        double percentile;
    };

    std::vector<DriverRanking> get_driver_leaderboard(int limit = 100)
    {
        std::vector<DriverRanking> rankings;

        auto all_drivers = db_.get_all_drivers();

        for (const auto &driver : all_drivers)
        {
            DriverRanking rank;
            rank.driver_id = driver.driver_id;
            rank.driver_name = driver.full_name;
            rank.safety_score = driver.safety_score;
            rank.total_distance = driver.total_distance;
            rankings.push_back(rank);
        }

        // Sort by safety score descending
        std::sort(rankings.begin(), rankings.end(),
                  [](const DriverRanking &a, const DriverRanking &b)
                  {
                      if (a.safety_score == b.safety_score)
                      {
                          return a.total_distance > b.total_distance;
                      }
                      return a.safety_score > b.safety_score;
                  });

        // Assign ranks and percentiles
        for (size_t i = 0; i < rankings.size(); i++)
        {
            rankings[i].rank = i + 1;
            rankings[i].percentile = ((double)(rankings.size() - i) / rankings.size()) * 100.0;
        }

        // Return top N
        if (rankings.size() > limit)
        {
            rankings.resize(limit);
        }

        return rankings;
    }

    struct DriverComparison
    {
        DriverBehaviorMetrics driver1;
        DriverBehaviorMetrics driver2;

        std::string better_safety_score;
        std::string better_fuel_efficiency;
        std::string safer_driver;

        double score_difference;
        double distance_difference;
    };

    DriverComparison compare_drivers(uint64_t driver1_id, uint64_t driver2_id)
    {
        DriverComparison comparison;

        comparison.driver1 = get_driver_behavior(driver1_id);
        comparison.driver2 = get_driver_behavior(driver2_id);

        // Compare safety scores
        if (comparison.driver1.safety_score > comparison.driver2.safety_score)
        {
            comparison.better_safety_score = "Driver 1";
            comparison.safer_driver = "Driver 1";
        }
        else
        {
            comparison.better_safety_score = "Driver 2";
            comparison.safer_driver = "Driver 2";
        }

        comparison.score_difference = abs((int)comparison.driver1.safety_score -
                                          (int)comparison.driver2.safety_score);
        comparison.distance_difference = abs(comparison.driver1.total_distance -
                                             comparison.driver2.total_distance);

        // Compare fuel efficiency
        if (comparison.driver1.avg_fuel_efficiency > comparison.driver2.avg_fuel_efficiency)
        {
            comparison.better_fuel_efficiency = "Driver 1";
        }
        else
        {
            comparison.better_fuel_efficiency = "Driver 2";
        }

        return comparison;
    }

    // ========================================================================
    // LICENSE & DOCUMENT ALERTS
    // ========================================================================

    struct DocumentAlert
    {
        uint64_t driver_id;
        std::string driver_name;
        std::string alert_type;
        uint64_t expiry_date;
        uint32_t days_until_expiry;
        uint8_t severity; // 1=Info, 2=Warning, 3=Critical
    };

    std::vector<DocumentAlert> get_license_expiry_alerts(int days_threshold = 30)
    {
        std::vector<DocumentAlert> alerts;

        auto all_drivers = db_.get_all_drivers();
        uint64_t current_time = get_current_timestamp();

        for (const auto &driver : all_drivers)
        {
            if (driver.license_expiry > 0)
            {
                int64_t days_until = (driver.license_expiry - current_time) / (86400ULL * 1000000000ULL);

                if (days_until <= days_threshold)
                {
                    DocumentAlert alert;
                    alert.driver_id = driver.driver_id;
                    alert.driver_name = driver.full_name;
                    alert.alert_type = "License Expiry";
                    alert.expiry_date = driver.license_expiry;
                    alert.days_until_expiry = days_until;

                    if (days_until <= 0)
                    {
                        alert.severity = 3; // Critical - expired
                    }
                    else if (days_until <= 7)
                    {
                        alert.severity = 3; // Critical - < 1 week
                    }
                    else if (days_until <= 14)
                    {
                        alert.severity = 2; // Warning - < 2 weeks
                    }
                    else
                    {
                        alert.severity = 1; // Info
                    }

                    alerts.push_back(alert);
                }
            }
        }

        return alerts;
    }

    // ========================================================================
    // DRIVER RECOMMENDATIONS
    // ========================================================================

    struct DriverRecommendation
    {
        std::string category;
        std::string recommendation;
        uint8_t priority; // 1=Low, 2=Medium, 3=High
        double potential_improvement;
    };

    std::vector<DriverRecommendation> get_improvement_recommendations(uint64_t driver_id)
    {
        std::vector<DriverRecommendation> recommendations;

        auto metrics = get_driver_behavior(driver_id);

        // Harsh braking recommendation
        if (metrics.harsh_braking_rate > 2.0)
        { // >2 per 100km
            DriverRecommendation rec;
            rec.category = "Braking Behavior";
            rec.recommendation = "Reduce harsh braking by anticipating stops earlier. "
                                 "This improves safety and fuel efficiency.";
            rec.priority = 3;
            rec.potential_improvement = 15.0; // 15% score improvement
            recommendations.push_back(rec);
        }

        // Speeding recommendation
        if (metrics.speeding_rate > 1.0)
        {
            DriverRecommendation rec;
            rec.category = "Speed Management";
            rec.recommendation = "Maintain speed limits to improve safety score and "
                                 "reduce fuel consumption.";
            rec.priority = 3;
            rec.potential_improvement = 20.0;
            recommendations.push_back(rec);
        }

        // Fuel efficiency recommendation
        if (metrics.avg_fuel_efficiency < 10.0)
        { // < 10 km/L
            DriverRecommendation rec;
            rec.category = "Fuel Efficiency";
            rec.recommendation = "Improve fuel efficiency by maintaining steady speeds "
                                 "and avoiding aggressive acceleration.";
            rec.priority = 2;
            rec.potential_improvement = 10.0;
            recommendations.push_back(rec);
        }

        // Vision-based recommendations
        if (metrics.distraction_events > 5)
        {
            DriverRecommendation rec;
            rec.category = "Driver Attention";
            rec.recommendation = "Minimize distractions while driving. Keep eyes on "
                                 "the road and avoid phone usage.";
            rec.priority = 3;
            rec.potential_improvement = 25.0;
            recommendations.push_back(rec);
        }

        return recommendations;
    }

    // ========================================================================
    // HELPER FUNCTIONS
    // ========================================================================
private:
    uint64_t get_current_timestamp()
    {
        return std::chrono::system_clock::now().time_since_epoch().count();
    }
    void calculate_driver_ranking(uint64_t driver_id, DriverBehaviorMetrics &metrics)
    {
        auto leaderboard = get_driver_leaderboard(10000);

        for (const auto &rank : leaderboard)
        {
            if (rank.driver_id == driver_id)
            {
                metrics.rank_in_fleet = rank.rank;
                metrics.percentile = rank.percentile;
                break;
            }
        }
    }
};
#endif // DRIVERMANAGER_H
#ifndef DATABASEMANAGER_H
#define DATABASEMANAGER_H

#include "../../include/sdm_types.hpp"
#include "../../include/sdm_config.hpp"
#include <fstream>
#include <string>
#include <vector>
#include <stdexcept>
#include <iostream>
#include <sys/stat.h>
#include <cstdlib>
#include <ctime>
#include <cstring>

using namespace std;

class DatabaseManager
{
private:
    fstream file_;
    string filename_;
    SDMHeader header_;
    bool is_open_;

    uint64_t driver_table_start_;
    uint64_t vehicle_table_start_;
    uint64_t trip_table_start_;
    uint64_t maintenance_table_start_;
    uint64_t expense_table_start_;
    uint64_t document_table_start_;
    uint64_t incident_table_start_;

    void calculate_offsets()
    {
        uint64_t current_offset = sizeof(SDMHeader);

        header_.driver_table_offset = current_offset;
        driver_table_start_ = current_offset;
        current_offset += header_.max_drivers * sizeof(DriverProfile);

        header_.vehicle_table_offset = current_offset;
        vehicle_table_start_ = current_offset;
        current_offset += header_.max_vehicles * sizeof(VehicleInfo);

        header_.trip_table_offset = current_offset;
        trip_table_start_ = current_offset;
        current_offset += header_.max_trips * sizeof(TripRecord);

        header_.maintenance_table_offset = current_offset;
        maintenance_table_start_ = current_offset;
        current_offset += 100000 * sizeof(MaintenanceRecord);

        header_.expense_table_offset = current_offset;
        expense_table_start_ = current_offset;
        current_offset += 500000 * sizeof(ExpenseRecord);

        header_.document_table_offset = current_offset;
        document_table_start_ = current_offset;
        current_offset += 100000 * sizeof(DocumentMetadata);

        header_.incident_table_offset = current_offset;
        incident_table_start_ = current_offset;
        current_offset += 50000 * sizeof(IncidentReport);

        header_.total_size = current_offset;
    }

public:
    DatabaseManager(const string &filename) : filename_(filename), is_open_(false) {}

    bool isOpen()
    {
        return is_open_;
    }

    ~DatabaseManager()
    {
        close();
    }

    bool create(const SDMConfig &config)
    {

        if (file_.is_open())
        {
            file_.close();
        }

        cout << "      Creating database: " << filename_ << endl;

        size_t last_slash = filename_.find_last_of('/');
        if (last_slash != string::npos)
        {
            string directory = filename_.substr(0, last_slash);
            struct stat st;
            if (stat(directory.c_str(), &st) != 0)
            {
                cout << "      Creating directory: " << directory << endl;
                string cmd = "mkdir -p \"" + directory + "\"";
                if (system(cmd.c_str()) != 0)
                {
                    cerr << "      ERROR: Failed to create directory!" << endl;
                }
            }
        }

        file_.open(filename_, ios::out | ios::binary | ios::trunc);
        if (!file_.is_open())
        {
            cerr << "      ERROR: Cannot create file: " << filename_ << endl;
            return false;
        }

        header_ = SDMHeader();
        header_.created_time = get_current_timestamp();
        header_.last_modified = header_.created_time;
        header_.max_drivers = config.max_drivers;
        header_.max_vehicles = config.max_vehicles;
        header_.max_trips = config.max_trips;

        calculate_offsets();

        file_.write(reinterpret_cast<const char *>(&header_), sizeof(SDMHeader));

        cout << "      Initializing " << header_.max_drivers << " driver slots..." << flush;
        DriverProfile empty_driver;
        empty_driver.is_active = 0;
        for (uint32_t i = 0; i < header_.max_drivers; i++)
        {
            file_.write(reinterpret_cast<const char *>(&empty_driver), sizeof(DriverProfile));
        }
        cout << " ✓" << endl;

        cout << "      Initializing " << header_.max_vehicles << " vehicle slots..." << flush;
        VehicleInfo empty_vehicle;
        empty_vehicle.is_active = 0;
        for (uint32_t i = 0; i < header_.max_vehicles; i++)
        {
            file_.write(reinterpret_cast<const char *>(&empty_vehicle), sizeof(VehicleInfo));
        }
        cout << " ✓" << endl;

        cout << "      Initializing " << header_.max_trips << " trip slots..." << flush;
        TripRecord empty_trip;
        for (uint32_t i = 0; i < header_.max_trips; i++)
        {
            file_.write(reinterpret_cast<const char *>(&empty_trip), sizeof(TripRecord));
        }
        cout << " ✓" << endl;

        cout << "      Initializing maintenance records..." << flush;
        MaintenanceRecord empty_maintenance;
        for (uint32_t i = 0; i < 100000; i++)
        {
            file_.write(reinterpret_cast<const char *>(&empty_maintenance), sizeof(MaintenanceRecord));
        }
        cout << " ✓" << endl;

        cout << "      Initializing expense records..." << flush;
        ExpenseRecord empty_expense;
        for (uint32_t i = 0; i < 500000; i++)
        {
            file_.write(reinterpret_cast<const char *>(&empty_expense), sizeof(ExpenseRecord));
        }
        cout << " ✓" << endl;

        cout << "      Initializing document metadata..." << flush;
        DocumentMetadata empty_doc;
        for (uint32_t i = 0; i < 100000; i++)
        {
            file_.write(reinterpret_cast<const char *>(&empty_doc), sizeof(DocumentMetadata));
        }
        cout << " ✓" << endl;

        cout << "      Initializing incident reports..." << flush;
        IncidentReport empty_incident;
        for (uint32_t i = 0; i < 50000; i++)
        {
            file_.write(reinterpret_cast<const char *>(&empty_incident), sizeof(IncidentReport));
        }
        cout << " ✓" << endl;

        file_.flush();
        file_.close();

        cout << "      Database created (" << (header_.total_size / 1024 / 1024) << " MB)" << endl;

        return true;
    }

    bool open()
    {
        file_.open(filename_, ios::in | ios::out | ios::binary);
        if (!file_.is_open())
        {
            return false;
        }

        file_.read(reinterpret_cast<char *>(&header_), sizeof(SDMHeader));

        if (string(header_.magic, 8) != "SDMDB001")
        {
            file_.close();
            return false;
        }

        driver_table_start_ = header_.driver_table_offset;
        vehicle_table_start_ = header_.vehicle_table_offset;
        trip_table_start_ = header_.trip_table_offset;
        maintenance_table_start_ = header_.maintenance_table_offset;
        expense_table_start_ = header_.expense_table_offset;
        document_table_start_ = header_.document_table_offset;
        incident_table_start_ = header_.incident_table_offset;

        is_open_ = true;
        return true;
    }

    void close()
    {
        if (is_open_ && file_.is_open())
        {
            header_.last_modified = get_current_timestamp();
            file_.seekp(0, ios::beg);
            file_.write(reinterpret_cast<const char *>(&header_), sizeof(SDMHeader));
            file_.flush();
            file_.close();
            is_open_ = false;
        }
    }

    bool create_driver(const DriverProfile &driver)
    {
        if (!is_open_)
            return false;

        for (uint32_t i = 0; i < header_.max_drivers; i++)
        {
            DriverProfile existing;
            uint64_t offset = driver_table_start_ + (i * sizeof(DriverProfile));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&existing), sizeof(DriverProfile));

            if (existing.is_active == 0)
            {
                file_.seekp(offset, ios::beg);
                file_.write(reinterpret_cast<const char *>(&driver), sizeof(DriverProfile));
                file_.flush();
                return true;
            }
        }

        return false;
    }

    bool read_driver(uint64_t driver_id, DriverProfile &driver)
    {
        if (!is_open_)
            return false;

        for (uint32_t i = 0; i < header_.max_drivers; i++)
        {
            uint64_t offset = driver_table_start_ + (i * sizeof(DriverProfile));
            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&driver), sizeof(DriverProfile));

            if (driver.is_active == 1 && driver.driver_id == driver_id)
            {
                return true;
            }
        }

        return false;
    }

    bool update_driver(const DriverProfile &driver)
    {
        if (!is_open_)
            return false;

        for (uint32_t i = 0; i < header_.max_drivers; i++)
        {
            DriverProfile existing;
            uint64_t offset = driver_table_start_ + (i * sizeof(DriverProfile));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&existing), sizeof(DriverProfile));

            if (existing.is_active == 1 && existing.driver_id == driver.driver_id)
            {
                file_.seekp(offset, ios::beg);
                file_.write(reinterpret_cast<const char *>(&driver), sizeof(DriverProfile));
                file_.flush();
                return true;
            }
        }

        return false;
    }

    bool delete_driver(uint64_t driver_id)
    {
        if (!is_open_)
            return false;

        for (uint32_t i = 0; i < header_.max_drivers; i++)
        {
            DriverProfile driver;
            uint64_t offset = driver_table_start_ + (i * sizeof(DriverProfile));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&driver), sizeof(DriverProfile));

            if (driver.is_active == 1 && driver.driver_id == driver_id)
            {
                driver.is_active = 0;
                file_.seekp(offset, ios::beg);
                file_.write(reinterpret_cast<const char *>(&driver), sizeof(DriverProfile));
                file_.flush();
                return true;
            }
        }

        return false;
    }

    vector<DriverProfile> get_all_drivers()
    {
        vector<DriverProfile> drivers;
        if (!is_open_)
            return drivers;

        for (uint32_t i = 0; i < header_.max_drivers; i++)
        {
            DriverProfile driver;
            uint64_t offset = driver_table_start_ + (i * sizeof(DriverProfile));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&driver), sizeof(DriverProfile));

            if (driver.is_active == 1)
            {
                drivers.push_back(driver);
            }
        }

        return drivers;
    }

    bool create_vehicle(const VehicleInfo &vehicle)
    {
        if (!is_open_)
            return false;

        for (uint32_t i = 0; i < header_.max_vehicles; i++)
        {
            VehicleInfo existing;
            uint64_t offset = vehicle_table_start_ + (i * sizeof(VehicleInfo));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&existing), sizeof(VehicleInfo));

            if (existing.is_active == 0)
            {
                file_.seekp(offset, ios::beg);
                file_.write(reinterpret_cast<const char *>(&vehicle), sizeof(VehicleInfo));
                file_.flush();
                return true;
            }
        }

        return false;
    }

    bool read_vehicle(uint64_t vehicle_id, VehicleInfo &vehicle)
    {
        if (!is_open_)
            return false;

        for (uint32_t i = 0; i < header_.max_vehicles; i++)
        {
            uint64_t offset = vehicle_table_start_ + (i * sizeof(VehicleInfo));
            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&vehicle), sizeof(VehicleInfo));

            if (vehicle.is_active == 1 && vehicle.vehicle_id == vehicle_id)
            {
                return true;
            }
        }

        return false;
    }

    bool update_vehicle(const VehicleInfo &vehicle)
    {
        if (!is_open_)
            return false;

        for (uint32_t i = 0; i < header_.max_vehicles; i++)
        {
            VehicleInfo existing;
            uint64_t offset = vehicle_table_start_ + (i * sizeof(VehicleInfo));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&existing), sizeof(VehicleInfo));

            if (existing.is_active == 1 && existing.vehicle_id == vehicle.vehicle_id)
            {
                file_.seekp(offset, ios::beg);
                file_.write(reinterpret_cast<const char *>(&vehicle), sizeof(VehicleInfo));
                file_.flush();
                return true;
            }
        }

        return false;
    }

    bool delete_vehicle(uint64_t vehicle_id)
    {
        if (!is_open_)
            return false;

        for (uint32_t i = 0; i < header_.max_vehicles; i++)
        {
            VehicleInfo vehicle;
            uint64_t offset = vehicle_table_start_ + (i * sizeof(VehicleInfo));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&vehicle), sizeof(VehicleInfo));

            if (vehicle.is_active == 1 && vehicle.vehicle_id == vehicle_id)
            {
                vehicle.is_active = 0;
                file_.seekp(offset, ios::beg);
                file_.write(reinterpret_cast<const char *>(&vehicle), sizeof(VehicleInfo));
                file_.flush();
                return true;
            }
        }

        return false;
    }

    vector<VehicleInfo> get_vehicles_by_owner(uint64_t owner_id)
    {
        vector<VehicleInfo> vehicles;
        if (!is_open_)
            return vehicles;

        for (uint32_t i = 0; i < header_.max_vehicles; i++)
        {
            VehicleInfo vehicle;
            uint64_t offset = vehicle_table_start_ + (i * sizeof(VehicleInfo));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&vehicle), sizeof(VehicleInfo));

            if (vehicle.is_active == 1 && vehicle.owner_driver_id == owner_id)
            {
                vehicles.push_back(vehicle);
            }
        }

        return vehicles;
    }

    bool create_trip(const TripRecord &trip)
    {
        if (!is_open_)
            return false;

        for (uint32_t i = 0; i < header_.max_trips; i++)
        {
            TripRecord existing;
            uint64_t offset = trip_table_start_ + (i * sizeof(TripRecord));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&existing), sizeof(TripRecord));

            if (existing.trip_id == 0)
            {
                file_.seekp(offset, ios::beg);
                file_.write(reinterpret_cast<const char *>(&trip), sizeof(TripRecord));
                file_.flush();
                return true;
            }
        }

        return false;
    }

    bool read_trip(uint64_t trip_id, TripRecord &trip)
    {
        if (!is_open_)
            return false;

        for (uint32_t i = 0; i < header_.max_trips; i++)
        {
            uint64_t offset = trip_table_start_ + (i * sizeof(TripRecord));
            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&trip), sizeof(TripRecord));

            if (trip.trip_id == trip_id)
            {
                return true;
            }
        }

        return false;
    }

    bool update_trip(const TripRecord &trip)
    {
        if (!is_open_)
            return false;

        for (uint32_t i = 0; i < header_.max_trips; i++)
        {
            TripRecord existing;
            uint64_t offset = trip_table_start_ + (i * sizeof(TripRecord));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&existing), sizeof(TripRecord));

            if (existing.trip_id == trip.trip_id)
            {
                file_.seekp(offset, ios::beg);
                file_.write(reinterpret_cast<const char *>(&trip), sizeof(TripRecord));
                file_.flush();
                return true;
            }
        }

        return false;
    }

    vector<TripRecord> get_trips_by_driver(uint64_t driver_id, int limit = 100)
    {
        vector<TripRecord> trips;
        if (!is_open_)
            return trips;

        int count = 0;
        for (uint32_t i = 0; i < header_.max_trips && count < limit; i++)
        {
            TripRecord trip;
            uint64_t offset = trip_table_start_ + (i * sizeof(TripRecord));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&trip), sizeof(TripRecord));

            if (trip.trip_id != 0 && trip.driver_id == driver_id)
            {
                trips.push_back(trip);
                count++;
            }
        }

        return trips;
    }

    bool create_maintenance(const MaintenanceRecord &record)
    {
        if (!is_open_)
            return false;

        for (uint32_t i = 0; i < 100000; i++)
        {
            MaintenanceRecord existing;
            uint64_t offset = maintenance_table_start_ + (i * sizeof(MaintenanceRecord));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&existing), sizeof(MaintenanceRecord));

            if (existing.maintenance_id == 0)
            {
                file_.seekp(offset, ios::beg);
                file_.write(reinterpret_cast<const char *>(&record), sizeof(MaintenanceRecord));
                file_.flush();
                return true;
            }
        }

        return false;
    }

    vector<MaintenanceRecord> get_maintenance_by_vehicle(uint64_t vehicle_id)
    {
        vector<MaintenanceRecord> records;
        if (!is_open_)
            return records;

        for (uint32_t i = 0; i < 100000; i++)
        {
            MaintenanceRecord record;
            uint64_t offset = maintenance_table_start_ + (i * sizeof(MaintenanceRecord));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&record), sizeof(MaintenanceRecord));

            if (record.maintenance_id != 0 && record.vehicle_id == vehicle_id)
            {
                records.push_back(record);
            }
        }

        return records;
    }

    bool create_expense(const ExpenseRecord &expense)
    {
        if (!is_open_)
            return false;

        for (uint32_t i = 0; i < 500000; i++)
        {
            ExpenseRecord existing;
            uint64_t offset = expense_table_start_ + (i * sizeof(ExpenseRecord));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&existing), sizeof(ExpenseRecord));

            if (existing.expense_id == 0)
            {
                file_.seekp(offset, ios::beg);
                file_.write(reinterpret_cast<const char *>(&expense), sizeof(ExpenseRecord));
                file_.flush();
                return true;
            }
        }

        return false;
    }

    vector<ExpenseRecord> get_expenses_by_driver(uint64_t driver_id, int limit = 100)
    {
        vector<ExpenseRecord> expenses;
        if (!is_open_)
            return expenses;

        int count = 0;
        for (uint32_t i = 0; i < 500000 && count < limit; i++)
        {
            ExpenseRecord expense;
            uint64_t offset = expense_table_start_ + (i * sizeof(ExpenseRecord));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&expense), sizeof(ExpenseRecord));

            if (expense.expense_id != 0 && expense.driver_id == driver_id)
            {
                expenses.push_back(expense);
                count++;
            }
        }

        return expenses;
    }

    vector<ExpenseRecord> get_expenses_by_category(uint64_t driver_id, ExpenseCategory category)
    {
        vector<ExpenseRecord> expenses;
        if (!is_open_)
            return expenses;

        for (uint32_t i = 0; i < 500000; i++)
        {
            ExpenseRecord expense;
            uint64_t offset = expense_table_start_ + (i * sizeof(ExpenseRecord));

            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&expense), sizeof(ExpenseRecord));

            if (expense.expense_id != 0 && expense.driver_id == driver_id &&
                expense.category == category)
            {
                expenses.push_back(expense);
            }
        }

        return expenses;
    }

    uint64_t get_current_timestamp() const
    {
        return static_cast<uint64_t>(time(nullptr));
    }

    const SDMHeader &get_header() const { return header_; }
    bool is_database_open() const { return is_open_; }

    DatabaseStats get_stats()
    {
        DatabaseStats stats;
        if (!is_open_)
            return stats;

        for (uint32_t i = 0; i < header_.max_drivers; i++)
        {
            DriverProfile driver;
            uint64_t offset = driver_table_start_ + (i * sizeof(DriverProfile));
            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&driver), sizeof(DriverProfile));

            if (driver.is_active == 1)
            {
                stats.total_drivers++;
                stats.active_drivers++;
                stats.total_distance += driver.total_distance;
            }
        }

        for (uint32_t i = 0; i < header_.max_vehicles; i++)
        {
            VehicleInfo vehicle;
            uint64_t offset = vehicle_table_start_ + (i * sizeof(VehicleInfo));
            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&vehicle), sizeof(VehicleInfo));

            if (vehicle.is_active == 1)
            {
                stats.total_vehicles++;
            }
        }

        for (uint32_t i = 0; i < header_.max_trips; i++)
        {
            TripRecord trip;
            uint64_t offset = trip_table_start_ + (i * sizeof(TripRecord));
            file_.seekg(offset, ios::beg);
            file_.read(reinterpret_cast<char *>(&trip), sizeof(TripRecord));

            if (trip.trip_id != 0)
            {
                stats.total_trips++;
            }
        }

        stats.database_size = header_.total_size;
        stats.used_space = stats.database_size;

        return stats;
    }
};

#endif


#ifndef CACHEMANAGER_H
#define CACHEMANAGER_H

#include "../../source/data_structures/HashTable.h"
#include "../../include/sdm_types.hpp"
#include <memory>
#include <string>
#include <chrono>
#include <iostream>
using namespace std;

template<typename T>
struct CacheEntry {
    T data;
    uint64_t timestamp;
    uint32_t access_count;
    bool dirty;
    
    CacheEntry() : timestamp(0), access_count(0), dirty(false) {}
    CacheEntry(const T& d) : data(d), access_count(0), dirty(false) {
        timestamp = chrono::system_clock::now().time_since_epoch().count();
    }
};

class CacheManager {
private:
    LRUCache<uint64_t, CacheEntry<DriverProfile>> driver_cache_;
    LRUCache<uint64_t, CacheEntry<VehicleInfo>> vehicle_cache_;
    LRUCache<uint64_t, CacheEntry<TripRecord>> trip_cache_;
    
    LRUCache<string, SessionInfo> session_cache_;
    
    HashTable<string, vector<uint64_t>> query_result_cache_;
    
    uint64_t driver_hits_;
    uint64_t driver_misses_;
    uint64_t vehicle_hits_;
    uint64_t vehicle_misses_;
    uint64_t trip_hits_;
    uint64_t trip_misses_;
    uint64_t session_hits_;
    uint64_t session_misses_;

public:
    CacheManager(size_t driver_capacity = 256, 
                 size_t vehicle_capacity = 256,
                 size_t trip_capacity = 512,
                 size_t session_capacity = 1024)
        : driver_cache_(driver_capacity),
          vehicle_cache_(vehicle_capacity),
          trip_cache_(trip_capacity),
          session_cache_(session_capacity),
          driver_hits_(0), driver_misses_(0),
          vehicle_hits_(0), vehicle_misses_(0),
          trip_hits_(0), trip_misses_(0),
          session_hits_(0), session_misses_(0) {}
    
    bool get_driver(uint64_t driver_id, DriverProfile& driver) {
        CacheEntry<DriverProfile> entry;
        if (driver_cache_.get(driver_id, entry)) {
            driver = entry.data;
            entry.access_count++;
            driver_cache_.put(driver_id, entry);
            driver_hits_++;
            return true;
        }
        driver_misses_++;
        return false;
    }
    
    void put_driver(uint64_t driver_id, const DriverProfile& driver, bool dirty = false) {
        CacheEntry<DriverProfile> entry(driver);
        entry.dirty = dirty;
        driver_cache_.put(driver_id, entry);
    }
    
    void invalidate_driver(uint64_t driver_id) {
        driver_cache_.remove(driver_id);
    }
    
    bool get_vehicle(uint64_t vehicle_id, VehicleInfo& vehicle) {
        CacheEntry<VehicleInfo> entry;
        if (vehicle_cache_.get(vehicle_id, entry)) {
            vehicle = entry.data;
            entry.access_count++;
            vehicle_cache_.put(vehicle_id, entry);
            vehicle_hits_++;
            return true;
        }
        vehicle_misses_++;
        return false;
    }
    
    void put_vehicle(uint64_t vehicle_id, const VehicleInfo& vehicle, bool dirty = false) {
        CacheEntry<VehicleInfo> entry(vehicle);
        entry.dirty = dirty;
        vehicle_cache_.put(vehicle_id, entry);
    }
    
    void invalidate_vehicle(uint64_t vehicle_id) {
        vehicle_cache_.remove(vehicle_id);
    }
    
    bool get_trip(uint64_t trip_id, TripRecord& trip) {
        CacheEntry<TripRecord> entry;
        if (trip_cache_.get(trip_id, entry)) {
            trip = entry.data;
            entry.access_count++;
            trip_cache_.put(trip_id, entry);
            trip_hits_++;
            return true;
        }
        trip_misses_++;
        return false;
    }
    
    void put_trip(uint64_t trip_id, const TripRecord& trip, bool dirty = false) {
        CacheEntry<TripRecord> entry(trip);
        entry.dirty = dirty;
        trip_cache_.put(trip_id, entry);
    }
    
    void invalidate_trip(uint64_t trip_id) {
        trip_cache_.remove(trip_id);
    }
    
    
    bool get_session(const string& session_id, SessionInfo& session) {
        if (session_cache_.get(session_id, session)) {
            
            uint64_t current_time = chrono::system_clock::now().time_since_epoch().count();
            uint64_t elapsed = (current_time - session.last_activity) / 1000000000; 
            
            if (elapsed > 1800) { 
                session_cache_.remove(session_id);
                session_misses_++;
                return false;
            }
            
            session.last_activity = current_time;
            session_cache_.put(session_id, session); 
            session_hits_++;
            return true;
        }
        session_misses_++;
        return false;
    }
    
    void put_session(const string& session_id, const SessionInfo& session) {
        session_cache_.put(session_id, session);
    }
    
    void invalidate_session(const string& session_id) {
        session_cache_.remove(session_id);
    }
    
    
    bool get_query_result(const string& query_key, vector<uint64_t>& results) {
        return query_result_cache_.get(query_key, results);
    }
    
    void put_query_result(const string& query_key, const vector<uint64_t>& results) {
        query_result_cache_.insert(query_key, results);
    }
    
    void invalidate_query_result(const string& query_key) {
        query_result_cache_.remove(query_key);
    }
    
    void clear_query_cache() {
        query_result_cache_.clear();
    }
    
    
    struct CacheStats {
        uint64_t driver_hits;
        uint64_t driver_misses;
        double driver_hit_rate;
        
        uint64_t vehicle_hits;
        uint64_t vehicle_misses;
        double vehicle_hit_rate;
        
        uint64_t trip_hits;
        uint64_t trip_misses;
        double trip_hit_rate;
        
        uint64_t session_hits;
        uint64_t session_misses;
        double session_hit_rate;
        
        size_t driver_cache_size;
        size_t vehicle_cache_size;
        size_t trip_cache_size;
        size_t session_cache_size;
        size_t query_cache_size;
    };
    
    CacheStats get_stats() const {
        CacheStats stats;
        
        stats.driver_hits = driver_hits_;
        stats.driver_misses = driver_misses_;
        stats.driver_hit_rate = (driver_hits_ + driver_misses_ > 0) 
            ? (double)driver_hits_ / (driver_hits_ + driver_misses_) : 0.0;
        
        stats.vehicle_hits = vehicle_hits_;
        stats.vehicle_misses = vehicle_misses_;
        stats.vehicle_hit_rate = (vehicle_hits_ + vehicle_misses_ > 0)
            ? (double)vehicle_hits_ / (vehicle_hits_ + vehicle_misses_) : 0.0;
        
        stats.trip_hits = trip_hits_;
        stats.trip_misses = trip_misses_;
        stats.trip_hit_rate = (trip_hits_ + trip_misses_ > 0)
            ? (double)trip_hits_ / (trip_hits_ + trip_misses_) : 0.0;
        
        stats.session_hits = session_hits_;
        stats.session_misses = session_misses_;
        stats.session_hit_rate = (session_hits_ + session_misses_ > 0)
            ? (double)session_hits_ / (session_hits_ + session_misses_) : 0.0;
        
        stats.driver_cache_size = driver_cache_.size();
        stats.vehicle_cache_size = vehicle_cache_.size();
        stats.trip_cache_size = trip_cache_.size();
        stats.session_cache_size = session_cache_.size();
        stats.query_cache_size = query_result_cache_.size();
        
        return stats;
    }
    
    void reset_stats() {
        driver_hits_ = 0;
        driver_misses_ = 0;
        vehicle_hits_ = 0;
        vehicle_misses_ = 0;
        trip_hits_ = 0;
        trip_misses_ = 0;
        session_hits_ = 0;
        session_misses_ = 0;
    }
    
    
    void clear_all() {
        driver_cache_.clear();
        vehicle_cache_.clear();
        trip_cache_.clear();
        session_cache_.clear();
        query_result_cache_.clear();
    }
    
    void clear_expired_sessions() {
        cout << "void clear_expired_sessions(); is not implemented yet.";
    }
    
    void warmup_driver_cache(const vector<DriverProfile>& drivers) {
        for (const auto& driver : drivers) {
            put_driver(driver.driver_id, driver);
        }
    }
    
    void warmup_vehicle_cache(const vector<VehicleInfo>& vehicles) {
        for (const auto& vehicle : vehicles) {
            put_vehicle(vehicle.vehicle_id, vehicle);
        }
    }
};

#endif